#!/usr/bin/env python3
"""
================================================================================
æ¶æ„è§’è‰²: ä¸»å…¥å£ / å¤šæ¨¡å‹ CLI ç½‘å…³
åŠŸèƒ½æè¿°: æ”¯æŒ Gemini/GLM/Official API çš„å¤šè½®ä¼šè¯å‘½ä»¤è¡Œå·¥å…·
================================================================================
è¾“å…¥: CLIå‚æ•° / ç”¨æˆ·äº¤äº’è¾“å…¥ / å›¾ç‰‡æ–‡ä»¶
è¾“å‡º: stdout (AIå›å¤) / ä¼šè¯å†å²æ–‡ä»¶
ä¾èµ–: claude-code (å­è¿›ç¨‹è°ƒç”¨), python libs (wcwidth, sqlite3)
é…ç½®: ~/.gchat/.env (åç«¯ API åœ°å€å’Œå¯†é’¥)
================================================================================
å…¥å£:
  gchat                    # äº¤äº’å¼å¯¹è¯ (é»˜è®¤ flash3 æ¨¡å‹ï¼Œæ˜¾ç¤º spinner çŠ¶æ€)
  gchat -p "é—®é¢˜"          # å•æ¬¡æé—® (é™é»˜æ¨¡å¼ï¼Œä¸æ˜¾ç¤ºçŠ¶æ€)
  gchat -c                 # ç»§ç»­ä¸Šæ¬¡ä¼šè¯
  gchat -m pro             # æŒ‡å®šæ¨¡å‹
  gchat -d "æè¿°"          # æ–‡ç”Ÿå›¾
  gchat -D image.png       # å›¾ç‰‡åˆ†æ
ç›¸å…³:
  bin/turing               # ä¸»ç¨‹åºå‰¯æœ¬ (åŠŸèƒ½ç›¸åŒ)
  bin/gflashchat           # flash3 å¿«æ·æ–¹å¼
  bin/claudeminimax*       # MiniMax API åŒ…è£…å™¨
================================================================================
"""

import argparse
import json
import os
import sys
import subprocess
import readline  # æ”¯æŒå†å²è®°å½•å’Œè¡Œç¼–è¾‘
import base64
import mimetypes
import re
import shlex
import shutil
import signal
import glob as glob_module
import threading
import time
import sqlite3
from pathlib import Path

from wcwidth import wcswidth, wcwidth


_CTRL_CHARS_RE = re.compile(r"[\x00-\x08\x0b\x0c\x0e-\x1f\x7f]")


def sanitize_terminal_paste(text: str) -> str:
    """æ¸…ç†ç»ˆç«¯ç²˜è´´å¯èƒ½å¸¦æ¥çš„æ§åˆ¶å­—ç¬¦/è½¬ä¹‰åºåˆ—ã€‚

    ç›®çš„ï¼šé¿å…æŠŠä¸å¯è§æ§åˆ¶å­—ç¬¦å¸¦è¿› prompt / API è¯·æ±‚ï¼Œæˆ–è§¦å‘å¿«æ·é”®è¡Œä¸ºã€‚
    """
    if not text:
        return text

    # ç»Ÿä¸€æ¢è¡Œ
    text = text.replace("\r\n", "\n").replace("\r", "\n")

    # å¸¸è§çš„ bracketed paste åŒ…è£¹
    text = text.replace("\x1b[200~", "").replace("\x1b[201~", "")

    # ç§»é™¤ä¸å¯è§æ§åˆ¶å­—ç¬¦ï¼ˆä¿ç•™æ¢è¡Œ/åˆ¶è¡¨ç¬¦ï¼‰
    return _CTRL_CHARS_RE.sub("", text)

try:
    from prompt_toolkit import prompt as pt_prompt
    from prompt_toolkit.formatted_text import ANSI as PTANSI, HTML
    from prompt_toolkit.history import FileHistory
    from prompt_toolkit.key_binding import KeyBindings
except Exception:
    pt_prompt = None
    PTANSI = None
    HTML = None
    FileHistory = None
    KeyBindings = None


# ==================== é…ç½®åŠ è½½ ====================

def _load_env_file():
    """åŠ è½½ .env é…ç½®æ–‡ä»¶ (æ”¯æŒå¤šä¸ªä½ç½®)"""
    env_paths = [
        Path.home() / ".gchat" / ".env",  # ç”¨æˆ·é…ç½®ç›®å½•
        Path(__file__).parent.parent / ".env",  # é¡¹ç›®ç›®å½•
        Path.cwd() / ".env",  # å½“å‰ç›®å½•
    ]

    for env_path in env_paths:
        if env_path.exists():
            with open(env_path, 'r', encoding='utf-8') as f:
                for line in f:
                    line = line.strip()
                    if line and not line.startswith('#') and '=' in line:
                        key, _, value = line.partition('=')
                        key = key.strip()
                        value = value.strip().strip('"').strip("'")
                        if key and value and key not in os.environ:
                            os.environ[key] = value
            break  # åªåŠ è½½ç¬¬ä¸€ä¸ªæ‰¾åˆ°çš„ .env

_load_env_file()


# ==================== åç«¯é…ç½® ====================
# æ ¹æ®å‘½ä»¤åç§°ï¼ˆgchat/turingï¼‰è‡ªåŠ¨è¯»å–å¯¹åº”ç¯å¢ƒå˜é‡
def get_backend_config():
    """æ ¹æ®å‘½ä»¤åç§°è·å–åç«¯é…ç½®"""
    command_name = os.path.basename(sys.argv[0])

    if command_name == "turing":
        return {
            "url": os.environ.get("TURING_BASE_URL", ""),
            "key": os.environ.get("TURING_SPECIAL_GEMINI_GROUP_KEY", ""),
            "name": "Turing",
        }
    else:  # gchat
        return {
            "url": os.environ.get("GCHAT_BASE_URL", ""),
            "key": os.environ.get("GCHAT_KEY", ""),
            "name": "GChat",
        }

# è·å–å½“å‰åç«¯é…ç½®
BACKEND_CONFIG = get_backend_config()

# å®˜æ–¹APIæ¨¡å‹æ˜ å°„ (é€†å‘æ¨¡å‹å -> å®˜æ–¹æ¨¡å‹å)
OFFICIAL_MODEL_MAP = {
    "gemini-3-flash-preview": "gemini-2.5-flash-lite",
    "gemini-2.5-flash": "gemini-2.5-flash-lite",
    "gemini-2.5-pro": "gemini-2.5-flash-lite",  # proæ²¡å…è´¹é¢åº¦ï¼Œé™çº§åˆ°flash-lite
    "gemini-3.0-pro": "gemini-2.5-flash-lite",
}

# æ¨¡å‹åˆ«å
MODEL_ALIASES = {
    "pro3": "gemini-3-pro-preview",
    "flash3": "gemini-3-flash-preview",  # â­ gchat é»˜è®¤
    "flash": "gemini-3-flash-preview",
    "flash2": "gemini-2.5-flash",  # æ—§ç‰ˆ Flash
    "pro": "gemini-2.5-pro",
    "3": "gemini-3.0-pro",
}

# æ¨¡å‹é™çº§æ˜ å°„ (gemini-3 å¤±è´¥æ—¶é™çº§åˆ° gemini-2.5)
FALLBACK_MODELS = {
    "gemini-3-pro-preview": "gemini-2.5-pro",
    "gemini-3-flash-preview": "gemini-2.5-flash",
}

# å›¾ç‰‡ç”Ÿæˆæ¨¡å‹
IMAGE_MODELS = {
    "image": "gemini-3-pro-image-preview",  # é»˜è®¤
    "image-flash": "gemini-2.5-flash-image",
}

# å›¾ç‰‡ç”Ÿæˆé»˜è®¤æ¨¡å‹
DEFAULT_IMAGE_MODEL = "gemini-3-pro-image-preview"

# R2 å­˜å‚¨é…ç½® (ç”¨äºä¸Šä¼ ç”Ÿæˆçš„å›¾ç‰‡)
R2_CONFIG = {
    "access_key_id": os.environ.get("R2_ACCESS_KEY_ID", ""),
    "secret_access_key": os.environ.get("R2_SECRET_ACCESS_KEY", ""),
    "bucket": os.environ.get("R2_BUCKET", "gchat"),
    "endpoint": os.environ.get("R2_ENDPOINT", ""),
    "public_url": os.environ.get("R2_PUBLIC_URL", ""),
}

# NexusAI å›¾ç‰‡ç”Ÿæˆé…ç½®
NEXUSAI_IMAGE_CONFIG = {
    "url": os.environ.get("NEXUSAI_IMAGE_URL", ""),
    "key": os.environ.get("NEXUSAI_IMAGE_KEY", ""),
}

# GPT-Load å›¾ç‰‡ç”Ÿæˆé…ç½® (Cookieæ¨¡å¼)
GPTLOAD_IMAGE_CONFIG = {
    "url": os.environ.get("GPTLOAD_IMAGE_URL", ""),
    "key": os.environ.get("GPTLOAD_IMAGE_KEY", ""),
}

# ZYAI å›¾ç‰‡ç”Ÿæˆé…ç½®
ZYAI_IMAGE_CONFIG = {
    "url": os.environ.get("ZYAI_IMAGE_URL", ""),
    "key": os.environ.get("ZYAI_IMAGE_KEY", ""),
}

# YUNWU Chat å›¾ç‰‡ç”Ÿæˆé…ç½®
YUNWU_IMAGE_CONFIG = {
    "url": os.environ.get("YUNWU_IMAGE_URL", ""),
    "key": os.environ.get("YUNWU_IMAGE_KEY", ""),
}

# Google-API å›¾ç‰‡ç”Ÿæˆé…ç½® (Cookieæ¨¡å¼ï¼Œæ— éœ€Key)
GOOGLE_API_IMAGE_CONFIG = {
    "url": os.environ.get("GOOGLE_API_IMAGE_URL", os.environ.get("GOOGLE_API_URL", "")),
}

# é¢„å®šä¹‰çš„å¸¸ç”¨å·¥å…·
BUILTIN_TOOLS = {
    "weather": {
        "name": "get_weather",
        "description": "è·å–æŒ‡å®šåŸå¸‚çš„å¤©æ°”ä¿¡æ¯",
        "parameters": {
            "type": "object",
            "properties": {
                "city": {"type": "string", "description": "åŸå¸‚åç§°ï¼Œå¦‚'åŒ—äº¬'ã€'ä¸Šæµ·'"}
            },
            "required": ["city"]
        }
    },
    "search": {
        "name": "web_search",
        "description": "æœç´¢ç½‘é¡µè·å–ä¿¡æ¯",
        "parameters": {
            "type": "object",
            "properties": {
                "query": {"type": "string", "description": "æœç´¢å…³é”®è¯"}
            },
            "required": ["query"]
        }
    },
    "calculator": {
        "name": "calculate",
        "description": "æ‰§è¡Œæ•°å­¦è®¡ç®—",
        "parameters": {
            "type": "object",
            "properties": {
                "expression": {"type": "string", "description": "æ•°å­¦è¡¨è¾¾å¼ï¼Œå¦‚'2+2'ã€'sqrt(16)'"}
            },
            "required": ["expression"]
        }
    },
    "bash": {
        "name": "run_bash",
        "description": "æ‰§è¡Œbashå‘½ä»¤",
        "parameters": {
            "type": "object",
            "properties": {
                "command": {"type": "string", "description": "è¦æ‰§è¡Œçš„bashå‘½ä»¤"}
            },
            "required": ["command"]
        }
    },
    "write": {
        "name": "write_file",
        "description": "å°†å†…å®¹å†™å…¥æ–‡ä»¶ã€‚å½“ç”¨æˆ·è¦æ±‚ä¿å­˜å†…å®¹åˆ°æ–‡ä»¶æ—¶ä½¿ç”¨æ­¤å·¥å…·ã€‚",
        "parameters": {
            "type": "object",
            "properties": {
                "path": {"type": "string", "description": "æ–‡ä»¶è·¯å¾„ï¼Œå¦‚ 'poem.md'ã€'output.txt'"},
                "content": {"type": "string", "description": "è¦å†™å…¥çš„å†…å®¹"}
            },
            "required": ["path", "content"]
        }
    },
    "read": {
        "name": "read_file",
        "description": "è¯»å–æ–‡ä»¶å†…å®¹ã€‚å½“ç”¨æˆ·è¦æ±‚åˆ†ææˆ–æŸ¥çœ‹æ–‡ä»¶æ—¶ä½¿ç”¨æ­¤å·¥å…·ã€‚",
        "parameters": {
            "type": "object",
            "properties": {
                "path": {"type": "string", "description": "æ–‡ä»¶è·¯å¾„"}
            },
            "required": ["path"]
        }
    },
}

# é¢œè‰²è¾“å‡º
class Color:
    BLUE = '\033[94m'
    GREEN = '\033[92m'
    YELLOW = '\033[93m'
    RED = '\033[91m'
    CYAN = '\033[96m'
    MAGENTA = '\033[95m'
    DIM = '\033[2m'
    BOLD = '\033[1m'
    END = '\033[0m'

def colored(text, color):
    """è¿”å›å¸¦é¢œè‰²çš„æ–‡æœ¬"""
    if not sys.stdout.isatty():
        return text
    return f"{color}{text}{Color.END}"


ANSI_ESCAPE_RE = re.compile(r"\x1b\[[0-9;]*m")


def readline_safe_prompt(prompt: str) -> str:
    """è®©å¸¦ ANSI é¢œè‰²çš„ prompt åœ¨ readline ä¸‹ä¸ç ´åæ¢è¡Œ/å…‰æ ‡å®šä½ã€‚

    Python çš„ readline ä¼šæŠŠ ANSI æ§åˆ¶åºåˆ—ä¹Ÿè®¡å…¥é•¿åº¦ï¼Œå¯¼è‡´é•¿æ–‡æœ¬è‡ªåŠ¨æ¢è¡Œæ—¶å…‰æ ‡é”™ä½ã€‚
    ç”¨ \001/\002 åŒ…è£¹ä¸å¯è§å­—ç¬¦ç‰‡æ®µå¯ä¿®å¤è¯¥é—®é¢˜ã€‚
    """
    if not sys.stdin.isatty():
        return prompt

    try:
        # è‹¥ readline ä¸å¯ç”¨ï¼Œç›´æ¥è¿”å›
        import readline as _  # noqa: F401
    except Exception:
        return prompt

    def _wrap(match: re.Match[str]) -> str:
        return f"\001{match.group(0)}\002"

    return ANSI_ESCAPE_RE.sub(_wrap, prompt)


def get_gchat_dir() -> str:
    """è·å–gchatæ•°æ®ç›®å½•ï¼Œä¸å­˜åœ¨åˆ™åˆ›å»º"""
    home = os.path.expanduser('~')
    gchat_dir = os.path.join(home, '.gchat')
    os.makedirs(gchat_dir, exist_ok=True)
    return gchat_dir

def get_sessions_dir() -> str:
    """è·å–ä¼šè¯å†å²ç›®å½•"""
    sessions_dir = os.path.join(get_gchat_dir(), 'sessions')
    os.makedirs(sessions_dir, exist_ok=True)
    return sessions_dir

def get_input_history_path() -> str:
    return os.path.join(get_gchat_dir(), 'input_history')


def print_box(title: str, content: str) -> None:
    width = shutil.get_terminal_size((100, 20)).columns
    width = max(60, min(width, 140))

    label = f"[{title}]"
    top = f"â”Œ{label}{'â”€' * max(1, width - 2 - len(label))}â”"
    bottom = f"â””{'â”€' * (width - 2)}â”˜"
    print(colored(top, Color.CYAN))

    def _wrap_display(raw: str, max_w: int) -> list[str]:
        if raw == "":
            return [""]

        out: list[str] = []
        buf: list[str] = []
        cur_w = 0
        for ch in raw.replace('\t', '    '):
            ch_w = wcwidth(ch)
            if ch_w < 0:
                ch_w = 0
            if cur_w + ch_w > max_w and buf:
                out.append(''.join(buf))
                buf = [ch]
                cur_w = ch_w
                continue
            buf.append(ch)
            cur_w += ch_w
        out.append(''.join(buf))
        return out

    inner_w = width - 4
    lines = content.splitlines() or [""]
    for raw in lines:
        for wline in _wrap_display(raw, inner_w):
            line_w = wcswidth(wline)
            if line_w < 0:
                line_w = len(wline)
            pad = " " * max(0, inner_w - line_w)
            print(colored("â”‚ ", Color.CYAN) + wline + pad + colored(" â”‚", Color.CYAN))

    print(colored(bottom, Color.CYAN))


def is_image_file(path: Path) -> bool:
    if not path.is_file():
        return False

    suffix = path.suffix.lower().lstrip('.')
    return suffix in {
        'png', 'jpg', 'jpeg', 'gif', 'webp', 'bmp', 'tiff', 'tif', 'heic'
    }


def encode_image_to_data_url(path: Path) -> str:
    mime, _ = mimetypes.guess_type(str(path))
    if not mime:
        # å°½é‡ç»™ä¸€ä¸ªåˆç†é»˜è®¤
        mime = f"image/{path.suffix.lower().lstrip('.')}" if path.suffix else "application/octet-stream"

    data = path.read_bytes()
    b64 = base64.b64encode(data).decode('ascii')
    return f"data:{mime};base64,{b64}"


def download_url_to_temp(url: str) -> Path | None:
    """ä¸‹è½½ç½‘ç»œå›¾ç‰‡åˆ°ä¸´æ—¶æ–‡ä»¶

    Args:
        url: å›¾ç‰‡URL

    Returns:
        ä¸´æ—¶æ–‡ä»¶è·¯å¾„ï¼Œå¤±è´¥è¿”å› None
    """
    import urllib.request
    import urllib.error
    import tempfile

    # æ£€æµ‹æ˜¯å¦ä¸º URL
    if not url.startswith(('http://', 'https://')):
        return None

    try:
        # åˆ›å»ºä¸´æ—¶æ–‡ä»¶
        with tempfile.NamedTemporaryFile(delete=False, suffix='.png') as tmp:
            # ä¸‹è½½å›¾ç‰‡
            request = urllib.request.Request(url, headers={'User-Agent': 'Mozilla/5.0'})
            with urllib.request.urlopen(request, timeout=30) as response:
                tmp.write(response.read())
            return Path(tmp.name)
    except Exception as e:
        return None


def resolve_image_path(path_or_url: str) -> Path | None:
    """è§£æå›¾ç‰‡è·¯å¾„ï¼ˆæ”¯æŒæœ¬åœ°è·¯å¾„å’Œç½‘ç»œURLï¼‰

    Args:
        path_or_url: æœ¬åœ°è·¯å¾„æˆ–ç½‘ç»œURL

    Returns:
        å®é™…å¯è¯»å–çš„å›¾ç‰‡è·¯å¾„ï¼Œå¤±è´¥è¿”å› None
    """
    path = Path(path_or_url).expanduser()

    # æœ¬åœ°æ–‡ä»¶å­˜åœ¨
    if path.exists():
        return path

    # å°è¯•ä¸‹è½½ç½‘ç»œå›¾ç‰‡
    if path_or_url.startswith(('http://', 'https://')):
        return download_url_to_temp(path_or_url)

    return None


def extract_local_image_paths(text: str) -> tuple[str, list[Path]]:
    """ä»ç”¨æˆ·è¾“å…¥ä¸­æå–æœ¬åœ°å›¾ç‰‡è·¯å¾„ï¼ˆç”¨äºæ‹–æ‹½æ–‡ä»¶åˆ°ç»ˆç«¯åœºæ™¯ï¼‰ã€‚

    æ”¯æŒå¸¦ç©ºæ ¼çš„è·¯å¾„ï¼ˆå¦‚ /path/to/å›¾ç‰‡ 1.png æ–‡å­—æè¿°ï¼‰
    - ä»…å½“ token æŒ‡å‘çœŸå®å­˜åœ¨çš„æ–‡ä»¶ä¸”æ‰©å±•åæ˜¯å›¾ç‰‡æ—¶æ‰è®¤å®šä¸ºå›¾ç‰‡ã€‚
    - è¿”å›ï¼šç§»é™¤å›¾ç‰‡è·¯å¾„åçš„æ–‡æœ¬ + å›¾ç‰‡è·¯å¾„åˆ—è¡¨
    """
    # ä»…å¯¹å•è¡Œè¾“å…¥åšè‡ªåŠ¨è¯†åˆ«ï¼Œé¿å…ç ´åç”¨æˆ·å¤šè¡Œæ–‡æœ¬æ ¼å¼
    if '\n' in text:
        return text, []

    try:
        tokens = shlex.split(text, posix=True)
    except ValueError:
        # å¼•å·ä¸é…å¯¹ç­‰æƒ…å†µï¼šä¿å®ˆå¤„ç†ï¼Œä¸è‡ªåŠ¨æå–
        return text, []

    image_paths: list[Path] = []
    remaining: list[str] = []
    i = 0

    while i < len(tokens):
        tok = tokens[i]

        # å¦‚æœ token ä»¥ / å¼€å¤´ï¼Œå¯èƒ½æ˜¯è·¯å¾„çš„å¼€å§‹
        if tok.startswith('/'):
            # è´ªå©ªåœ°å°è¯•åˆå¹¶åç»­æ‰€æœ‰ tokensï¼Œæ‰¾åˆ°æœ€é•¿çš„æœ‰æ•ˆå›¾ç‰‡è·¯å¾„
            found_image = None
            merged_count = 0

            # å°è¯•ä»å½“å‰ä½ç½®å¼€å§‹çš„æ‰€æœ‰å¯èƒ½çš„åˆå¹¶é•¿åº¦
            for j in range(i, len(tokens)):
                candidate = ' '.join(tokens[i:j+1])
                p = Path(candidate).expanduser()

                if is_image_file(p):
                    # æ‰¾åˆ°æœ‰æ•ˆå›¾ç‰‡ï¼Œæ›´æ–°ä¸ºæœ€é•¿åŒ¹é…ï¼ˆç»§ç»­å°è¯•æ›´é•¿çš„ç»„åˆï¼‰
                    found_image = p
                    merged_count = j - i + 1

            if found_image:
                image_paths.append(found_image)
                i += merged_count
                continue

        # ä¸æ˜¯å›¾ç‰‡è·¯å¾„ï¼ŒåŠ å…¥ remaining
        remaining.append(tok)
        i += 1

    cleaned_text = ' '.join(remaining).strip()
    return cleaned_text, image_paths


def normalize_messages_for_api(messages: list[dict]) -> list[dict]:
    """æŠŠæœ¬åœ° message ç»“æ„è½¬æ¢ä¸º OpenAI å…¼å®¹ payloadã€‚

    æ”¯æŒ content ä¸ºï¼š
    - str
    - list[{type:'text', text:'...'} | {type:'image_file', path:'...'}]
    """
    out: list[dict] = []
    for msg in messages:
        content = msg.get('content')
        if isinstance(content, list):
            parts: list[dict] = []
            for part in content:
                if part.get('type') == 'text':
                    text = part.get('text', '')
                    if text:
                        parts.append({"type": "text", "text": text})
                elif part.get('type') == 'image_file':
                    path_str = part.get('path')
                    if not path_str:
                        continue
                    p = Path(path_str).expanduser()
                    if not is_image_file(p):
                        continue
                    parts.append({
                        "type": "image_url",
                        "image_url": {"url": encode_image_to_data_url(p)},
                    })
                elif part.get('type') == 'image_url':
                    # å…¼å®¹å·²æ˜¯ OpenAI æ ¼å¼çš„å†å²è®°å½•
                    image_url = part.get('image_url')
                    if isinstance(image_url, dict) and image_url.get('url'):
                        parts.append({"type": "image_url", "image_url": {"url": image_url["url"]}})
                else:
                    # æœªçŸ¥ part ç±»å‹ï¼šå¿½ç•¥
                    continue

            # å¦‚æœ parts ä¸ºç©ºï¼Œè‡³å°‘ç»™ä¸€ä¸ªç©ºæ–‡æœ¬ï¼Œé¿å…éƒ¨åˆ†åç«¯æŠ¥é”™
            if not parts:
                parts = [{"type": "text", "text": ""}]

            out.append({"role": msg.get('role'), "content": parts})
        else:
            out.append({"role": msg.get('role'), "content": content})

    return out


class StatusSpinner:
    """è¯·æ±‚çŠ¶æ€æ˜¾ç¤ºå™¨ - Claude Code é£æ ¼"""
    WORDS = ["Thinking", "Processing", "Generating", "Working"]

    def __init__(self):
        self._stop = threading.Event()
        self._thread = None
        self._start_time = 0
        self._char_idx = 0
        self._word_idx = 0

    def _animate(self):
        chars = ["Â·", ":", "Â·"]
        while not self._stop.is_set():
            elapsed = int(time.time() - self._start_time)
            if elapsed < 60:
                time_str = f"{elapsed}s"
            else:
                time_str = f"{elapsed // 60}m {elapsed % 60}s"

            word = self.WORDS[self._word_idx % len(self.WORDS)]
            char = chars[self._char_idx % len(chars)]

            status = f"\r\033[K{colored('*', Color.YELLOW)} {word}{char * 3} {colored(f'(ctrl+c to interrupt Â· {time_str})', Color.DIM)}"
            sys.stdout.write(status)
            sys.stdout.flush()

            self._char_idx += 1
            if self._char_idx % 10 == 0:
                self._word_idx += 1
            self._stop.wait(0.15)

    def start(self):
        self._start_time = time.time()
        self._stop.clear()
        self._char_idx = 0
        self._word_idx = 0
        self._thread = threading.Thread(target=self._animate, daemon=True)
        self._thread.start()

    def stop(self):
        self._stop.set()
        if self._thread:
            self._thread.join(timeout=0.5)
        sys.stdout.write("\r\033[K")
        sys.stdout.flush()


TIPS = [
    "git commit -m 'fix' åå‘ç°è¿˜æœ‰ bugï¼Œè¿™æ˜¯å®¿å‘½",
    "ä»£ç èƒ½è·‘å°±ä¸è¦åŠ¨ï¼Œé™¤éä½ æƒ³åŠ ç­",
    "æ²¡æœ‰ä»€ä¹ˆæ˜¯é‡å¯è§£å†³ä¸äº†çš„",
    "ä»Šå¤©å†™çš„ä»£ç ï¼Œæ˜å¤©å°±çœ‹ä¸æ‡‚äº†",
    "ä¸å…¶ä¼˜åŒ–ä»£ç ï¼Œä¸å¦‚ä¼˜åŒ–éœ€æ±‚",
    "deadline æ˜¯ç¬¬ä¸€ç”Ÿäº§åŠ›",
    "å¥½ä»£ç è‡ªå·±ä¼šè¯´è¯ï¼Œåä»£ç éœ€è¦æ³¨é‡Š",
    "å…ˆè®©å®ƒè·‘ï¼Œå†è®©å®ƒå¯¹ï¼Œæœ€åè®©å®ƒå¿«",
    "ä¸€ä¸ª TODO æ”¾ä¸‰å¹´ï¼Œå°±æˆäº† TODON'T",
    "If it works, don't touch it",
    "99 ä¸ª bug ä¿®å®Œï¼Œè¿˜å‰© 127 ä¸ª",
    "ç¨‹åºå‘˜æœ€è®¨åŒçš„ä¸¤ä»¶äº‹ï¼šå†™æ³¨é‡Šå’Œæ²¡æ³¨é‡Š",
    "è¿™æ®µä»£ç ä¸ºä»€ä¹ˆèƒ½è·‘ï¼Ÿåˆ«é—®ï¼Œé—®å°±æ˜¯ç„å­¦",
    "rm -rf / ä¸€æ—¶çˆ½ï¼Œä¸€ç›´ rm ä¸€ç›´çˆ½ï¼Ÿ",
    "ä½ çš„ä»£ç ä¸æ˜¯å±å±±ï¼Œæ˜¯å±å–œé©¬æ‹‰é›…",
    "Talk is cheap, show me the code",
    "It works on my machine",
    "æ°¸è¿œä¸è¦ç›¸ä¿¡ç”¨æˆ·è¾“å…¥",
    "å¤åˆ¶ç²˜è´´ï¼Œç¨‹åºå‘˜çš„æ ¸å¿ƒç«äº‰åŠ›",
    "å†™ä»£ç ä¸€æ—¶çˆ½ï¼Œé‡æ„ç«è‘¬åœº",
]

def get_tip():
    """æ ¹æ®æ—¶é—´æˆ³é€‰æ‹©æ®µå­ï¼Œæ¯æ¬¡å¯åŠ¨ä¸åŒ"""
    idx = int(time.time()) % len(TIPS)
    return TIPS[idx]


# ============== åå¥½æŒä¹…åŒ– ==============
def get_preferences_path():
    """è·å–åå¥½æ–‡ä»¶è·¯å¾„"""
    return os.path.expanduser("~/.gchat/GCHAT.md")

def load_preferences():
    """åŠ è½½ GCHAT.md ä½œä¸ºç³»ç»Ÿæç¤º

    ç±»ä¼¼ Claude Code çš„ CLAUDE.mdï¼Œç”¨äºå­˜å‚¨ç”¨æˆ·åå¥½å’Œé¡¹ç›®ä¸Šä¸‹æ–‡
    """
    path = get_preferences_path()
    if os.path.exists(path):
        try:
            with open(path, 'r', encoding='utf-8') as f:
                content = f.read().strip()
            if content:
                return content
        except Exception:
            pass
    return None


# ============== ä¸Šä¸‹æ–‡å‹ç¼© ==============
# å‹ç¼©é…ç½®
CONTEXT_CONFIG = {
    "max_messages": 20,       # æœ€å¤§æ¶ˆæ¯æ•°
    "compress_threshold": 16, # è§¦å‘å‹ç¼©çš„é˜ˆå€¼
    "preserve_recent": 6,     # ä¿ç•™æœ€è¿‘Næ¡æ¶ˆæ¯ä¸å‹ç¼©
    "summary_max_len": 500,   # æ‘˜è¦æœ€å¤§é•¿åº¦
}

def estimate_tokens(text):
    """ç²—ç•¥ä¼°ç®— token æ•°ï¼ˆä¸­æ–‡çº¦1.5å­—/tokenï¼Œè‹±æ–‡çº¦4å­—ç¬¦/tokenï¼‰"""
    if not text:
        return 0
    chinese_chars = len(re.findall(r'[\u4e00-\u9fff]', text))
    other_chars = len(text) - chinese_chars
    return int(chinese_chars * 1.5 + other_chars / 4)

def compress_context(messages, backend_config, model):
    """æ™ºèƒ½ä¸Šä¸‹æ–‡å‹ç¼© - å€Ÿé‰´ Claude Code çš„ wU2 å‹ç¼©ç­–ç•¥

    å½“æ¶ˆæ¯æ•°è¶…è¿‡é˜ˆå€¼æ—¶ï¼š
    1. ä¿ç•™ system æ¶ˆæ¯
    2. ä¿ç•™æœ€è¿‘ N æ¡æ¶ˆæ¯
    3. å°†æ—§æ¶ˆæ¯å‹ç¼©ä¸ºæ‘˜è¦
    """
    if len(messages) < CONTEXT_CONFIG["compress_threshold"]:
        return messages, False

    # åˆ†ç¦» system æ¶ˆæ¯å’Œå¯¹è¯æ¶ˆæ¯
    system_msgs = [m for m in messages if m.get("role") == "system"]
    chat_msgs = [m for m in messages if m.get("role") != "system"]

    if len(chat_msgs) < CONTEXT_CONFIG["compress_threshold"]:
        return messages, False

    # ä¿ç•™æœ€è¿‘çš„æ¶ˆæ¯
    preserve_count = CONTEXT_CONFIG["preserve_recent"]
    old_msgs = chat_msgs[:-preserve_count]
    recent_msgs = chat_msgs[-preserve_count:]

    # ç”Ÿæˆæ‘˜è¦
    summary = generate_context_summary(old_msgs, backend_config, model)

    if summary:
        # æ„å»ºå‹ç¼©åçš„æ¶ˆæ¯åˆ—è¡¨
        compressed = system_msgs.copy()
        compressed.append({
            "role": "system",
            "content": f"[å¯¹è¯å†å²æ‘˜è¦]\n{summary}\n[ä»¥ä¸Šä¸ºæ—©æœŸå¯¹è¯æ‘˜è¦ï¼Œä»¥ä¸‹ä¸ºæœ€è¿‘å¯¹è¯]"
        })
        compressed.extend(recent_msgs)
        return compressed, True

    # å‹ç¼©å¤±è´¥ï¼Œè¿”å›åŸæ¶ˆæ¯ä½†æˆªæ–­
    return system_msgs + chat_msgs[-CONTEXT_CONFIG["max_messages"]:], False

def generate_context_summary(messages, backend_config, model):
    """ç”Ÿæˆå¯¹è¯æ‘˜è¦"""
    if not messages:
        return None

    # æ„å»ºè¦æ‘˜è¦çš„å†…å®¹
    content_parts = []
    for msg in messages:
        role = "ç”¨æˆ·" if msg.get("role") == "user" else "AI"
        content = msg.get("content", "")
        if isinstance(content, list):
            # å¤šæ¨¡æ€æ¶ˆæ¯ï¼Œåªå–æ–‡æœ¬éƒ¨åˆ†
            content = " ".join([p.get("text", "") for p in content if p.get("type") == "text"])
        # æˆªæ–­è¿‡é•¿çš„å•æ¡æ¶ˆæ¯
        if len(content) > 200:
            content = content[:200] + "..."
        content_parts.append(f"{role}: {content}")

    dialog_text = "\n".join(content_parts)

    # å¦‚æœå¯¹è¯å¤ªçŸ­ï¼Œä¸éœ€è¦æ‘˜è¦
    if len(dialog_text) < 300:
        return None

    # ä½¿ç”¨ API ç”Ÿæˆæ‘˜è¦
    summary_prompt = f"""è¯·ç”¨1-3å¥è¯ç®€æ´æ€»ç»“ä»¥ä¸‹å¯¹è¯çš„ä¸»è¦å†…å®¹å’Œå…³é”®ä¿¡æ¯ï¼Œä¸è¦é—æ¼é‡è¦ç»†èŠ‚ï¼š

{dialog_text[:2000]}

æ‘˜è¦ï¼š"""

    try:
        summary_messages = [{"role": "user", "content": summary_prompt}]
        # ä½¿ç”¨éæµå¼è¯·æ±‚è·å–æ‘˜è¦
        result = chat_request(summary_messages, model, backend_config, retry=1, debug=False)
        if result and not result.startswith("["):
            # é™åˆ¶æ‘˜è¦é•¿åº¦
            return result[:CONTEXT_CONFIG["summary_max_len"]]
    except Exception:
        pass

    # API è°ƒç”¨å¤±è´¥ï¼Œè¿”å›ç®€å•æ‘˜è¦
    turns = len(messages) // 2
    return f"[æ—©æœŸå¯¹è¯ {turns} è½®ï¼Œå†…å®¹å·²å‹ç¼©]"


LOGO_LINES = [
    " â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—   â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•— â–ˆâ–ˆâ•—  â–ˆâ–ˆâ•—  â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•— â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—",
    "â–ˆâ–ˆâ•”â•â•â•â•â•  â–ˆâ–ˆâ•”â•â•â•â•â• â–ˆâ–ˆâ•‘  â–ˆâ–ˆâ•‘ â–ˆâ–ˆâ•”â•â•â–ˆâ–ˆâ•—â•šâ•â•â–ˆâ–ˆâ•”â•â•â•",
    "â–ˆâ–ˆâ•‘  â–ˆâ–ˆâ–ˆâ•— â–ˆâ–ˆâ•‘      â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•‘ â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•‘   â–ˆâ–ˆâ•‘   ",
    "â–ˆâ–ˆâ•‘   â–ˆâ–ˆâ•‘ â–ˆâ–ˆâ•‘      â–ˆâ–ˆâ•”â•â•â–ˆâ–ˆâ•‘ â–ˆâ–ˆâ•”â•â•â–ˆâ–ˆâ•‘   â–ˆâ–ˆâ•‘   ",
    "â•šâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•”â• â•šâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•— â–ˆâ–ˆâ•‘  â–ˆâ–ˆâ•‘ â–ˆâ–ˆâ•‘  â–ˆâ–ˆâ•‘   â–ˆâ–ˆâ•‘   ",
    " â•šâ•â•â•â•â•â•   â•šâ•â•â•â•â•â• â•šâ•â•  â•šâ•â• â•šâ•â•  â•šâ•â•   â•šâ•â•   ",
]

def get_recent_sessions(limit=3):
    """è·å–æœ€è¿‘çš„ä¼šè¯"""
    sessions_dir = os.path.expanduser("~/.gchat/sessions")
    if not os.path.exists(sessions_dir):
        return []

    files = []
    for f in os.listdir(sessions_dir):
        if f.endswith('.json'):
            path = os.path.join(sessions_dir, f)
            files.append((os.path.getmtime(path), f, path))

    files.sort(reverse=True)

    recent = []
    for mtime, fname, path in files[:limit]:
        try:
            with open(path, 'r') as f:
                data = json.load(f)

            # æ”¯æŒä¸¤ç§æ ¼å¼ï¼šç›´æ¥æ•°ç»„ æˆ– {messages: [...]}
            messages = data.get('messages', data) if isinstance(data, dict) else data

            if messages and len(messages) > 0:
                first_msg = ""
                for msg in messages:
                    if msg.get('role') == 'user':
                        content = msg.get('content', '')
                        if isinstance(content, list):  # multimodal content
                            content = str(content[0].get('text', '')) if content else ''
                        first_msg = content[:22]
                        if len(content) > 22:
                            first_msg += "..."
                        break
                if first_msg:
                    time_str = time.strftime("%m/%d %H:%M", time.localtime(mtime))
                    recent.append((time_str, first_msg))
        except:
            pass

    return recent

def get_git_info():
    """è·å–å½“å‰ç›®å½•çš„Gitä¿¡æ¯"""
    try:
        import subprocess
        # æ£€æŸ¥æ˜¯å¦åœ¨gitä»“åº“ä¸­
        result = subprocess.run(['git', 'rev-parse', '--is-inside-work-tree'],
                              capture_output=True, text=True, timeout=2)
        if result.returncode != 0:
            return None

        # è·å–åˆ†æ”¯å
        result = subprocess.run(['git', 'branch', '--show-current'],
                              capture_output=True, text=True, timeout=2)
        branch = result.stdout.strip() if result.returncode == 0 else "unknown"

        # è·å–çŠ¶æ€ï¼ˆç®€çŸ­ï¼‰
        result = subprocess.run(['git', 'status', '--porcelain'],
                              capture_output=True, text=True, timeout=2)
        changes = len(result.stdout.strip().split('\n')) if result.stdout.strip() else 0

        return {"branch": branch, "changes": changes}
    except:
        return None

def print_header():
    """æ‰“å°æ¬¢è¿ä¿¡æ¯ - Claude Code é£æ ¼å¸¦è¾¹æ¡†çª—å£"""
    import re
    import shutil

    # è·å–ç»ˆç«¯å®½åº¦ï¼ˆå¤šç§æ–¹å¼å°è¯•ï¼‰
    term_width = 80
    try:
        # æ–¹æ³•1: shutilï¼ˆæœ€å¯é ï¼‰
        size = shutil.get_terminal_size()
        term_width = size.columns
    except:
        pass

    # æ–¹æ³•2: ç¯å¢ƒå˜é‡å¤‡é€‰
    if term_width <= 0:
        term_width = int(os.environ.get('COLUMNS', 80))

    # æ–¹æ³•3: tput (macOS/Linux)
    if term_width == 80:  # å¯èƒ½æ˜¯é»˜è®¤å€¼ï¼Œå°è¯• tput
        try:
            import subprocess
            result = subprocess.run(['tput', 'cols'], capture_output=True, text=True, timeout=1)
            if result.returncode == 0 and result.stdout.strip().isdigit():
                term_width = int(result.stdout.strip())
        except:
            pass

    # Logoå›ºå®šå®½åº¦46å­—ç¬¦ï¼Œè®¡ç®—å³ä¾§é¢æ¿å®½åº¦
    logo_width = 46
    # å†…å®¹å®½åº¦ = ç»ˆç«¯å®½åº¦ - 2(å·¦å³è¾¹æ¡†) - 1(ä¸­é—´åˆ†éš”)
    inner_width = term_width - 3
    left_width = logo_width
    right_width = inner_width - left_width

    # å¦‚æœç»ˆç«¯å¤ªçª„ï¼Œä¸æ˜¾ç¤ºå³ä¾§é¢æ¿
    show_right_panel = right_width >= 20

    if not show_right_panel:
        # çª„å±æ¨¡å¼ï¼šåªæ˜¾ç¤ºLogo
        inner_width = logo_width
        left_width = logo_width
        right_width = 0

    # è·å–æ•°æ®
    recent = get_recent_sessions(2)
    tip = get_tip()
    git_info = get_git_info()
    cwd = os.getcwd()

    # è¾¹æ¡†å­—ç¬¦
    TL, TR, BL, BR = 'â•­', 'â•®', 'â•°', 'â•¯'
    H, V = 'â”€', 'â”‚'
    VL, VR, TD, TU = 'â”œ', 'â”¤', 'â”¬', 'â”´'

    def visible_len(s):
        """è®¡ç®—å»é™¤ANSIç åçš„å¯è§é•¿åº¦ï¼ˆè€ƒè™‘ä¸­æ–‡å®½å­—ç¬¦ï¼‰"""
        # å»é™¤ANSIè½¬ä¹‰ç 
        text = re.sub(r'\x1b\[[0-9;]*m', '', str(s))
        width = 0
        for char in text:
            code = ord(char)
            # ä¸­æ–‡å’Œå…¨è§’å­—ç¬¦å 2æ ¼
            if (0x4E00 <= code <= 0x9FFF or    # CJKç»Ÿä¸€æ±‰å­—
                0x3000 <= code <= 0x303F or    # CJKæ ‡ç‚¹
                0xFF00 <= code <= 0xFFEF):     # å…¨è§’å­—ç¬¦
                width += 2
            else:
                width += 1
        return width

    def pad_right(text, width):
        """å³ä¾§å¡«å……åˆ°æŒ‡å®šå®½åº¦"""
        vlen = visible_len(text)
        return text + " " * max(0, width - vlen)

    # æ„å»ºå³ä¾§å†…å®¹
    right_lines = []
    if show_right_panel:
        max_text_len = right_width - 3  # ç•™å‡ºè¾¹è·

        # å½“å‰ç›®å½• (ç”¨ > ä»£æ›¿ emojiï¼Œé¿å…å®½åº¦é—®é¢˜)
        cwd_short = cwd if len(cwd) <= max_text_len - 2 else "..." + cwd[-(max_text_len-5):]
        right_lines.append(colored("> ", Color.YELLOW) + colored(cwd_short, Color.DIM))

        # Git ä¿¡æ¯
        if git_info:
            branch = git_info['branch'][:max_text_len-10]
            git_str = f"* {branch}"
            if git_info['changes'] > 0:
                git_str += f" ({git_info['changes']} changed)"
            right_lines.append(colored(git_str, Color.GREEN))
        else:
            right_lines.append(colored("* (not a git repo)", Color.DIM))

        # ç©ºè¡Œ
        right_lines.append("")

        # æœ€è¿‘ä¼šè¯
        right_lines.append(colored("Recent Sessions", Color.BOLD))
        if recent:
            for r in recent[:2]:
                session_text = f"  {r[0]} {r[1][:max_text_len-14]}"
                right_lines.append(colored(session_text, Color.DIM))
        else:
            right_lines.append(colored("  (no recent sessions)", Color.DIM))
            right_lines.append("")

        # è¡¥é½è¡Œæ•°
        while len(right_lines) < 6:
            right_lines.append("")

    # é¡¶éƒ¨è¾¹æ¡†
    if show_right_panel:
        print(colored(TL + H * left_width + TD + H * right_width + TR, Color.DIM))
    else:
        print(colored(TL + H * inner_width + TR, Color.DIM))

    # LogoåŒºåŸŸï¼ˆå·¦ä¾§ï¼‰+ ä¿¡æ¯ï¼ˆå³ä¾§ï¼‰
    for i, logo_line in enumerate(LOGO_LINES):
        # å·¦ä¾§ï¼šLogo
        left_content = " " + colored(logo_line, Color.MAGENTA)
        left_content = pad_right(left_content, left_width)

        if show_right_panel:
            # å³ä¾§ï¼šå†…å®¹
            right_text = right_lines[i] if i < len(right_lines) else ""
            right_content = " " + right_text
            right_content = pad_right(right_content, right_width)
            print(colored(V, Color.DIM) + left_content + colored(V, Color.DIM) + right_content + colored(V, Color.DIM))
        else:
            print(colored(V, Color.DIM) + left_content + colored(V, Color.DIM))

    # åˆ†éš”çº¿
    total_inner = left_width + right_width + (1 if show_right_panel else 0)
    if show_right_panel:
        print(colored(VL + H * left_width + TU + H * right_width + VR, Color.DIM))
    else:
        print(colored(VL + H * inner_width + VR, Color.DIM))

    # Tip è¡Œ (ç”¨ * ä»£æ›¿ emoji)
    tip_max = total_inner - 4
    tip_line = colored(" * ", Color.YELLOW) + colored(tip[:tip_max], Color.DIM)
    tip_line = pad_right(tip_line, total_inner)
    print(colored(V, Color.DIM) + tip_line + colored(V, Color.DIM))

    # åˆ†éš”çº¿
    print(colored(VL + H * total_inner + VR, Color.DIM))

    # åº•éƒ¨ä¿¡æ¯è¡Œ
    info_text = " v5.0  Â·  gchat-cli  Â·  /help for commands "
    info_line = pad_right(colored(info_text, Color.CYAN), total_inner)
    print(colored(V, Color.DIM) + info_line + colored(V, Color.DIM))

    # åº•éƒ¨è¾¹æ¡†
    print(colored(BL + H * total_inner + BR, Color.DIM))
    print()

def print_help():
    """æ‰“å°å¸®åŠ©ä¿¡æ¯ - Claude Code é£æ ¼"""
    print(colored("\nå‘½ä»¤å‰ç¼€: æ”¯æŒ : æˆ– / (ä¾‹å¦‚ :help æˆ– /help)\n", Color.CYAN))
    sections = [
        ("Commands", [
            (":help", "show help"),
            (":quit", "exit (auto-save)"),
            (":clear", "clear chat history"),
            (":history", "show chat history"),
        ]),
        ("Files", [
            (":read <file>", "read file for AI analysis"),
            (":write <file>", "save last AI reply to file"),
            (":img <path>", "analyze image"),
        ]),
        ("Sessions", [
            (":sessions", "list saved sessions"),
            (":save <file>", "save chat manually"),
            (":load <file>", "load chat"),
        ]),
        ("Settings", [
            (":model <name>", "switch model (flash/pro/pro3)"),
            (":backend <name>", "switch backend"),
            (":stream", "toggle streaming"),
            (":spinner", "toggle spinner animation"),
            (":mode [box]", "toggle input mode"),
            (":prefs [edit]", "manage preferences (GCHAT.md)"),
            (":status", "show current status"),
        ]),
    ]

    print()
    for section_name, items in sections:
        print(colored(f"  {section_name}", Color.BOLD))
        for cmd, desc in items:
            print(colored(f"    {cmd:<18}", Color.CYAN) + colored(desc, Color.DIM))
        print()

    print(colored("  Shortcuts", Color.BOLD))
    print(colored("    Ctrl+C", Color.CYAN) + colored("            save & continue", Color.DIM))
    print(colored("    Ctrl+D", Color.CYAN) + colored("            exit (auto-save)", Color.DIM))
    print()
    print(colored(f"  Storage: ~/.gchat/sessions/", Color.DIM))
    print()

def official_api_request(messages, model, tools=None, api_key=None):
    """ä½¿ç”¨Googleå®˜æ–¹APIå‘é€è¯·æ±‚ï¼ˆæ”¯æŒFunction Callingï¼‰"""
    if not api_key:
        api_key = os.environ.get("GEMINI_API_KEY", "")

    if not api_key:
        return None, "[é”™è¯¯] æœªè®¾ç½® GEMINI_API_KEY ç¯å¢ƒå˜é‡\nè®¾ç½®æ–¹æ³•: export GEMINI_API_KEY='your-api-key'"

    # æ˜ å°„åˆ°å®˜æ–¹æ¨¡å‹å
    official_model = OFFICIAL_MODEL_MAP.get(model, "gemini-2.5-flash-lite")

    # æ„å»ºå®˜æ–¹APIæ ¼å¼çš„è¯·æ±‚
    url = f"https://generativelanguage.googleapis.com/v1beta/models/{official_model}:generateContent?key={api_key}"

    # è½¬æ¢æ¶ˆæ¯æ ¼å¼ (OpenAI -> Gemini)
    contents = []
    for msg in messages:
        role = "user" if msg["role"] == "user" else "model"
        content = msg.get("content", "")
        if isinstance(content, str):
            contents.append({"role": role, "parts": [{"text": content}]})
        elif isinstance(content, list):
            parts = []
            for part in content:
                if part.get("type") == "text":
                    parts.append({"text": part.get("text", "")})
            if parts:
                contents.append({"role": role, "parts": parts})

    payload = {"contents": contents}

    # æ·»åŠ å·¥å…·å®šä¹‰
    if tools:
        payload["tools"] = [{"function_declarations": tools}]

    curl_cmd = [
        'curl', '-s', '-X', 'POST', url,
        '-H', 'Content-Type: application/json',
        '--max-time', '60',
        '-d', json.dumps(payload)
    ]

    try:
        result = subprocess.run(curl_cmd, capture_output=True, text=True, timeout=65)

        if result.returncode != 0:
            return None, f"[curlé”™è¯¯ {result.returncode}]: {result.stderr}"

        response_data = json.loads(result.stdout)

        # æ£€æŸ¥é”™è¯¯
        if "error" in response_data:
            error = response_data["error"]
            return None, f"[APIé”™è¯¯]: {error.get('message', json.dumps(error))}"

        # è§£æå“åº”
        candidates = response_data.get("candidates", [])
        if not candidates:
            return None, "[é”™è¯¯] æ— å“åº”å†…å®¹"

        content = candidates[0].get("content", {})
        parts = content.get("parts", [])

        for part in parts:
            # æ£€æŸ¥æ˜¯å¦æœ‰å‡½æ•°è°ƒç”¨
            if "functionCall" in part:
                fc = part["functionCall"]
                return {
                    "type": "function_call",
                    "name": fc.get("name"),
                    "args": fc.get("args", {})
                }, None
            # æ™®é€šæ–‡æœ¬å“åº”
            if "text" in part:
                return {"type": "text", "content": part["text"]}, None

        # è°ƒè¯•ï¼šæ‰“å°å®é™…å“åº”ç»“æ„
        return None, f"[é”™è¯¯] æ— æ³•è§£æå“åº”: {json.dumps(response_data, ensure_ascii=False)[:500]}"

    except subprocess.TimeoutExpired:
        return None, "[è¶…æ—¶]: å®˜æ–¹APIè¯·æ±‚è¶…è¿‡60ç§’"
    except json.JSONDecodeError as e:
        return None, f"[JSONè§£æé”™è¯¯]: {e}"
    except Exception as e:
        return None, f"[é”™è¯¯]: {e}"


def openai_tools_request(messages, model, tools, backend_config, retry=2):
    """å‘é€å¸¦å·¥å…·çš„è¯·æ±‚ï¼ˆOpenAI æ ¼å¼ï¼Œç”¨äº google åç«¯ï¼‰"""
    url = backend_config["url"]

    # è½¬æ¢å·¥å…·æ ¼å¼
    openai_tools = []
    for tool in tools:
        openai_tools.append({
            "type": "function",
            "function": {
                "name": tool["name"],
                "description": tool.get("description", ""),
                "parameters": tool.get("parameters", {"type": "object", "properties": {}})
            }
        })

    payload = {
        "model": model,
        "messages": normalize_messages_for_api(messages),
        "tools": openai_tools
    }

    curl_cmd = [
        'curl', '-s', '-X', 'POST', url,
        '-H', 'Content-Type: application/json',
        '--max-time', '120',
        '-d', json.dumps(payload)
    ]

    try:
        result = subprocess.run(curl_cmd, capture_output=True, text=True, timeout=125)

        if result.returncode != 0:
            return None, f"[curlé”™è¯¯ {result.returncode}]: {result.stderr}"

        response_data = json.loads(result.stdout)

        if "error" in response_data:
            return None, f"[APIé”™è¯¯]: {response_data['error'].get('message', str(response_data['error']))}"

        choice = response_data.get("choices", [{}])[0]
        message = choice.get("message", {})

        # æ£€æŸ¥æ˜¯å¦æœ‰å·¥å…·è°ƒç”¨
        if "tool_calls" in message and message["tool_calls"]:
            tc = message["tool_calls"][0]
            func = tc.get("function", {})
            return {
                "type": "function_call",
                "name": func.get("name"),
                "args": json.loads(func.get("arguments", "{}"))
            }, None

        # æ™®é€šæ–‡æœ¬å“åº”
        content = message.get("content", "")
        if content:
            return {"type": "text", "content": content}, None

        # è°ƒè¯•ï¼šæ‰“å°å®é™…å“åº”ç»“æ„
        return None, f"[é”™è¯¯] æ— æ³•è§£æå“åº”: {json.dumps(response_data, ensure_ascii=False)[:500]}"

    except subprocess.TimeoutExpired:
        return None, "[è¶…æ—¶]: è¯·æ±‚è¶…è¿‡120ç§’"
    except json.JSONDecodeError as e:
        return None, f"[JSONè§£æé”™è¯¯]: {e}\nå“åº”: {result.stdout[:300]}"
    except Exception as e:
        return None, f"[é”™è¯¯]: {e}"


def chat_request(messages, model, backend_config, retry=2, debug=False, show_spinner=True):
    """å‘é€èŠå¤©è¯·æ±‚ï¼ˆä½¿ç”¨curlï¼Œå…¼å®¹æ€§æœ€å¥½ï¼‰"""
    url = backend_config["url"]
    payload = {
        "model": model,
        "messages": normalize_messages_for_api(messages),
    }

    # æ„å»ºcurlå‘½ä»¤
    curl_cmd = [
        'curl', '-X', 'POST', url,
        '-H', 'Content-Type: application/json',
        '--max-time', '120',
        '--retry', str(retry),  # è‡ªåŠ¨é‡è¯•
        '--retry-delay', '2',    # é‡è¯•é—´éš”2ç§’
        '--connect-timeout', '30'  # è¿æ¥è¶…æ—¶30ç§’
    ]

    # è°ƒè¯•æ¨¡å¼æ˜¾ç¤ºè¯¦ç»†ä¿¡æ¯
    if not debug:
        curl_cmd.insert(1, '-s')  # é™é»˜æ¨¡å¼

    # å¦‚æœæœ‰API keyï¼Œæ·»åŠ Authorization header
    if "key" in backend_config:
        curl_cmd.extend(['-H', f'Authorization: Bearer {backend_config["key"]}'])

    # æ·»åŠ è¯·æ±‚ä½“
    curl_cmd.extend(['-d', json.dumps(payload)])

    spinner = StatusSpinner() if show_spinner else None

    try:
        if spinner:
            spinner.start()

        # æ‰§è¡Œcurlå‘½ä»¤
        result = subprocess.run(
            curl_cmd,
            capture_output=True,
            text=True,
            timeout=125
        )

        if spinner:
            spinner.stop()

        if result.returncode != 0:
            stderr_msg = result.stderr.strip() if result.stderr else "ç½‘ç»œè¿æ¥å¤±è´¥"

            # é’ˆå¯¹ curl 35 é”™è¯¯ç»™å‡ºå…·ä½“å»ºè®®
            if result.returncode == 35:
                return (
                    f"[SSL/TLSé”™è¯¯ 35]: {stderr_msg}\n\n"
                    f"å¯èƒ½åŸå› :\n"
                    f"1. ç½‘ç»œç¯å¢ƒé—®é¢˜ï¼ˆWiFiä¸ç¨³å®šã€VPNå¹²æ‰°ï¼‰\n"
                    f"2. DNSè§£æé—®é¢˜\n"
                    f"3. é˜²ç«å¢™/å®‰å…¨è½¯ä»¶é˜»æ­¢\n\n"
                    f"å»ºè®®:\n"
                    f"- é‡è¯•å‡ æ¬¡ï¼ˆå¯èƒ½æ˜¯ç¬æ—¶ç½‘ç»œæ³¢åŠ¨ï¼‰\n"
                    f"- åˆ‡æ¢ç½‘ç»œï¼ˆWiFi â†’ æœ‰çº¿ æˆ– æ‰‹æœºçƒ­ç‚¹ï¼‰\n"
                    f"- æ£€æŸ¥APIé…ç½®æ˜¯å¦æ­£ç¡®\n"
                    f"- æˆ–ä½¿ç”¨æœ¬åœ°åç«¯: gchat -b local"
                )

            return f"[curlé”™è¯¯ {result.returncode}]: {stderr_msg}\næç¤º: è¯·æ£€æŸ¥ç½‘ç»œè¿æ¥åé‡è¯•"

        # è§£æJSONå“åº”
        response_data = json.loads(result.stdout)

        # æ£€æŸ¥æ˜¯å¦æœ‰é”™è¯¯
        if "error" in response_data:
            error = response_data["error"]
            error_msg = error.get("message", "")
            error_type = error.get("type", "")
            error_code = error.get("code", "")

            # æ„å»ºè¯¦ç»†é”™è¯¯ä¿¡æ¯
            if error_msg:
                return f"[APIé”™è¯¯]: {error_msg}"
            elif error_type or error_code:
                return f"[APIé”™è¯¯]: {error_type or error_code}\nè¯¦æƒ…: {json.dumps(error, ensure_ascii=False)}"
            else:
                return f"[APIé”™è¯¯]: {json.dumps(error, ensure_ascii=False)}"

        # è¿”å›AIå›å¤
        return response_data["choices"][0]["message"]["content"]

    except subprocess.TimeoutExpired:
        if spinner:
            spinner.stop()
        return f"[è¶…æ—¶]: è¯·æ±‚è¶…è¿‡120ç§’"
    except json.JSONDecodeError as e:
        if spinner:
            spinner.stop()
        return f"[JSONè§£æé”™è¯¯]: {str(e)}\nå“åº”: {result.stdout[:200]}"
    except Exception as e:
        if spinner:
            spinner.stop()
        return f"[é”™è¯¯]: {str(e)}"

def resolve_model(model_input):
    """è§£ææ¨¡å‹åç§°"""
    return MODEL_ALIASES.get(model_input, model_input)


def chat_request_with_fallback(messages, model, backend_config, retry=2, debug=False, quiet=False, show_spinner=True):
    """å‘é€èŠå¤©è¯·æ±‚ï¼Œå¤±è´¥æ—¶è‡ªåŠ¨é™çº§åˆ°å¤‡ç”¨æ¨¡å‹"""
    # ç¬¬ä¸€æ¬¡å°è¯•ï¼šä½¿ç”¨ä¸»æ¨¡å‹
    response = chat_request(messages, model, backend_config, retry=retry, debug=debug, show_spinner=show_spinner)

    # æ£€æŸ¥æ˜¯å¦å¤±è´¥ï¼ˆé”™è¯¯å“åº”ä»¥ [ å¼€å¤´ï¼‰
    if response.startswith("[") and model in FALLBACK_MODELS:
        fallback_model = FALLBACK_MODELS[model]
        if not quiet:
            print(f"\nâš ï¸  {model} è¯·æ±‚å¤±è´¥ï¼Œé™çº§åˆ° {fallback_model}...")
        response = chat_request(messages, fallback_model, backend_config, retry=retry, debug=debug, show_spinner=show_spinner)
        if not response.startswith("[") and not quiet:
            print(f"âœ… é™çº§æˆåŠŸï¼Œä½¿ç”¨ {fallback_model} å“åº”\n")

    return response


def chat_request_stream(messages, model, backend_config, debug=False, show_spinner=True):
    """æµå¼å‘é€èŠå¤©è¯·æ±‚ï¼Œå…¼å®¹ SSE æµå’Œå®Œæ•´ JSON å“åº”"""
    url = backend_config["url"]
    payload = {
        "model": model,
        "messages": normalize_messages_for_api(messages),
        "stream": True,
    }

    # æ„å»ºcurlå‘½ä»¤
    curl_cmd = [
        'curl', '-X', 'POST', url,
        '-H', 'Content-Type: application/json',
        '-H', 'Accept: text/event-stream',
        '--max-time', '300',
        '--connect-timeout', '30',
        '-N',  # ç¦ç”¨ç¼“å†²
    ]

    if not debug:
        curl_cmd.insert(1, '-s')

    if "key" in backend_config:
        curl_cmd.extend(['-H', f'Authorization: Bearer {backend_config["key"]}'])

    curl_cmd.extend(['-d', json.dumps(payload)])

    spinner = StatusSpinner() if show_spinner else None

    # è€—æ—¶ç»Ÿè®¡
    start_time = time.time()
    ttfb_time = None  # Time to First Byte

    try:
        if spinner:
            spinner.start()

        process = subprocess.Popen(
            curl_cmd,
            stdout=subprocess.PIPE,
            stderr=subprocess.PIPE,
            text=True,
            bufsize=1,
        )

        full_response = ""
        raw_output = ""
        first_content = True

        for line in process.stdout:
            raw_output += line
            line = line.strip()
            if not line:
                continue

            # å°è¯• SSE æ ¼å¼
            if line.startswith("data: "):
                data = line[6:]
                if data == "[DONE]":
                    break
                try:
                    chunk = json.loads(data)
                    if "choices" in chunk and chunk["choices"]:
                        delta = chunk["choices"][0].get("delta", {})
                        content = delta.get("content", "")
                        if content:
                            if first_content and spinner:
                                spinner.stop()
                                ttfb_time = time.time() - start_time
                                first_content = False
                            print(content, end="", flush=True)
                            full_response += content
                except json.JSONDecodeError:
                    continue

        process.wait()

        # å¦‚æœæ²¡æœ‰ SSE æµæ•°æ®ï¼Œå°è¯•è§£æå®Œæ•´ JSON
        if not full_response and raw_output.strip():
            if spinner:
                spinner.stop()
            try:
                result = json.loads(raw_output.strip())
                if "choices" in result and result["choices"]:
                    content = result["choices"][0].get("message", {}).get("content", "")
                    if content:
                        print(content)
                        return content
            except json.JSONDecodeError:
                pass

        if full_response:
            print()  # æ¢è¡Œ
            # æ˜¾ç¤ºè€—æ—¶ç»Ÿè®¡
            total_time = time.time() - start_time
            ttfb_str = f"{ttfb_time:.1f}s" if ttfb_time else "N/A"
            print(colored(f"  â± TTFB: {ttfb_str} | Total: {total_time:.1f}s", Color.DIM))
        return full_response if full_response else "[æ— å“åº”]"

    except Exception as e:
        if spinner:
            spinner.stop()
        return f"[æµå¼è¯·æ±‚é”™è¯¯]: {str(e)}"
    finally:
        if spinner and first_content:  # spinner è¿˜åœ¨è¿è¡Œ
            spinner.stop()


def chat_request_with_fallback_stream(messages, model, backend_config, debug=False, show_spinner=True, quiet=False):
    """æµå¼è¯·æ±‚ï¼Œå¤±è´¥æ—¶é™çº§"""
    response = chat_request_stream(messages, model, backend_config, debug=debug, show_spinner=show_spinner)

    if response.startswith("[") and model in FALLBACK_MODELS:
        fallback_model = FALLBACK_MODELS[model]
        if not quiet:
            print(f"\nâš ï¸  {model} è¯·æ±‚å¤±è´¥ï¼Œé™çº§åˆ° {fallback_model}...")
        response = chat_request_stream(messages, fallback_model, backend_config, debug=debug, show_spinner=show_spinner)

    return response


def auto_save_history(messages, model):
    """è‡ªåŠ¨ä¿å­˜ä¼šè¯å†å²åˆ° ~/.gchat/sessions/"""
    if not messages or len(messages) == 0:
        return  # æ²¡æœ‰å¯¹è¯å†…å®¹ï¼Œä¸ä¿å­˜

    from datetime import datetime
    timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
    filename = os.path.join(get_sessions_dir(), f"gchat_history_{timestamp}.json")

    try:
        with open(filename, 'w', encoding='utf-8') as f:
            json.dump({
                "model": model,
                "messages": messages,
                "timestamp": timestamp
            }, f, ensure_ascii=False, indent=2)
        print(colored(f"ğŸ’¾ ä¼šè¯å·²è‡ªåŠ¨ä¿å­˜åˆ°: {filename}", Color.GREEN))
    except Exception as e:
        print(colored(f"âš ï¸  è‡ªåŠ¨ä¿å­˜å¤±è´¥: {e}", Color.RED))

def load_latest_history():
    """åŠ è½½æœ€æ–°çš„ä¼šè¯å†å²"""
    import glob

    sessions_dir = get_sessions_dir()
    history_files = glob.glob(os.path.join(sessions_dir, "gchat_history_*.json"))
    if not history_files:
        return None, None, None

    # æŒ‰æ–‡ä»¶åæ’åºï¼ˆæ–‡ä»¶ååŒ…å«æ—¶é—´æˆ³ï¼Œè‡ªç„¶æ’åºå³å¯ï¼‰
    latest_file = sorted(history_files)[-1]

    try:
        with open(latest_file, 'r', encoding='utf-8') as f:
            data = json.load(f)
            return data.get("messages", []), data.get("model", "gemini-3-flash-preview"), latest_file
    except Exception as e:
        print(colored(f"âš ï¸  åŠ è½½ä¼šè¯å¤±è´¥: {e}", Color.RED))
        return None, None, None


def list_sessions():
    """åˆ—å‡ºæ‰€æœ‰ä¼šè¯"""
    sessions_dir = get_sessions_dir()
    history_files = glob_module.glob(os.path.join(sessions_dir, "gchat_history_*.json"))

    if not history_files:
        print(colored("æ²¡æœ‰ä¿å­˜çš„ä¼šè¯", Color.YELLOW))
        return []

    sessions = []
    for f in sorted(history_files, reverse=True):
        try:
            with open(f, 'r', encoding='utf-8') as fp:
                data = json.load(fp)
                msg_count = len(data.get("messages", []))
                model = data.get("model", "unknown")
                timestamp = data.get("timestamp", "")
                # è·å–ç¬¬ä¸€æ¡ç”¨æˆ·æ¶ˆæ¯ä½œä¸ºé¢„è§ˆ
                preview = ""
                for msg in data.get("messages", []):
                    if msg.get("role") == "user":
                        content = msg.get("content", "")
                        if isinstance(content, str):
                            preview = content[:50] + "..." if len(content) > 50 else content
                        break
                sessions.append({
                    "file": f,
                    "timestamp": timestamp,
                    "model": model,
                    "msg_count": msg_count,
                    "preview": preview
                })
        except Exception:
            continue

    return sessions


def read_file_content(file_path):
    """è¯»å–æ–‡ä»¶å†…å®¹ç”¨äºAIåˆ†æ"""
    path = Path(file_path).expanduser()
    if not path.exists():
        return None, f"æ–‡ä»¶ä¸å­˜åœ¨: {file_path}"

    # æ£€æŸ¥æ˜¯å¦æ˜¯å›¾ç‰‡
    if is_image_file(path):
        return {"type": "image", "path": str(path)}, None

    # è¯»å–æ–‡æœ¬æ–‡ä»¶
    try:
        # é™åˆ¶æ–‡ä»¶å¤§å° (æœ€å¤§ 500KB)
        if path.stat().st_size > 500 * 1024:
            return None, f"æ–‡ä»¶è¿‡å¤§ (>{500}KB): {file_path}"

        with open(path, 'r', encoding='utf-8', errors='replace') as f:
            content = f.read()
        return {"type": "text", "content": content, "path": str(path)}, None
    except Exception as e:
        return None, f"è¯»å–å¤±è´¥: {e}"


def write_to_file(file_path, content):
    """å°†å†…å®¹å†™å…¥æ–‡ä»¶"""
    path = Path(file_path).expanduser()
    try:
        # ç¡®ä¿ç›®å½•å­˜åœ¨
        path.parent.mkdir(parents=True, exist_ok=True)
        with open(path, 'w', encoding='utf-8') as f:
            f.write(content)
        return True, str(path)
    except Exception as e:
        return False, str(e)


def execute_function(name, args):
    """æ‰§è¡Œå‡½æ•°è°ƒç”¨ï¼ˆæ¨¡æ‹Ÿå®ç°ï¼‰"""
    if name == "get_weather":
        city = args.get("city", "æœªçŸ¥")
        # æ¨¡æ‹Ÿå¤©æ°”æ•°æ®
        return {"city": city, "temperature": "15Â°C", "condition": "æ™´", "humidity": "45%"}
    elif name == "web_search":
        query = args.get("query", "")
        return {"results": [f"å…³äº '{query}' çš„æœç´¢ç»“æœ...", "æ›´å¤šå†…å®¹è¯·è®¿é—®æœç´¢å¼•æ“"]}
    elif name == "calculate":
        expr = args.get("expression", "0")
        try:
            # å®‰å…¨çš„æ•°å­¦è®¡ç®—
            import math
            allowed = {"sqrt": math.sqrt, "sin": math.sin, "cos": math.cos, "tan": math.tan,
                      "log": math.log, "exp": math.exp, "abs": abs, "round": round, "pow": pow}
            result = eval(expr, {"__builtins__": {}}, allowed)
            return {"expression": expr, "result": result}
        except Exception as e:
            return {"error": str(e)}
    elif name == "run_bash":
        command = args.get("command", "")
        try:
            result = subprocess.run(command, shell=True, capture_output=True, text=True, timeout=30)
            return {"command": command, "stdout": result.stdout, "stderr": result.stderr, "returncode": result.returncode}
        except Exception as e:
            return {"error": str(e)}
    elif name == "write_file":
        path = args.get("path", "")
        content = args.get("content", "")
        try:
            with open(path, "w", encoding="utf-8") as f:
                f.write(content)
            return {"success": True, "path": path, "message": f"å·²å†™å…¥ {len(content)} å­—ç¬¦åˆ° {path}"}
        except Exception as e:
            return {"error": str(e)}
    elif name == "read_file":
        path = args.get("path", "")
        try:
            with open(path, "r", encoding="utf-8") as f:
                content = f.read()
            return {"success": True, "path": path, "content": content[:5000]}  # é™åˆ¶é•¿åº¦
        except Exception as e:
            return {"error": str(e)}
    else:
        return {"error": f"æœªçŸ¥å‡½æ•°: {name}"}


def interactive_mode(model, continue_session=False, verbose=False):
    """äº¤äº’å¼å¤šè½®ä¼šè¯"""
    backend_config = BACKEND_CONFIG
    model = resolve_model(model)
    messages = []
    loaded_file = None
    # é»˜è®¤ä¸å¯ç”¨å·¥å…·ï¼Œé¿å…æ™®é€šæ¶ˆæ¯èµ°å·¥å…·è°ƒç”¨è·¯å¾„
    # ç”¨æˆ·å¯é€šè¿‡ /tools add read æ‰‹åŠ¨å¯ç”¨
    enabled_tools = []
    use_stream = True   # é»˜è®¤å¯ç”¨æµå¼è¾“å‡º
    show_spinner = True  # äº¤äº’æ¨¡å¼é»˜è®¤æ˜¾ç¤º spinnerï¼Œè®©ç”¨æˆ·çŸ¥é“æ­£åœ¨å¤„ç†

    # åŠ è½½ç”¨æˆ·åå¥½ (GCHAT.md) ä½œä¸ºç³»ç»Ÿæç¤º
    preferences = load_preferences()
    if preferences:
        messages.append({"role": "system", "content": preferences})
        print(colored("â—‹", Color.DIM) + " Loaded: " + colored("~/.gchat/GCHAT.md", Color.CYAN))

    # å¦‚æœæ˜¯ç»§ç»­ä¼šè¯æ¨¡å¼ï¼Œå°è¯•åŠ è½½æœ€è¿‘çš„å†å²
    if continue_session:
        loaded_messages, loaded_model, loaded_file = load_latest_history()
        if loaded_messages:
            # ä¿ç•™ system æ¶ˆæ¯ï¼Œè¿½åŠ å†å²å¯¹è¯
            if preferences:
                # è¿‡æ»¤æ‰å†å²ä¸­çš„ system æ¶ˆæ¯ï¼Œé¿å…é‡å¤
                loaded_messages = [m for m in loaded_messages if m.get("role") != "system"]
            messages.extend(loaded_messages)
            if loaded_model:
                model = loaded_model
            print(colored("â—‹", Color.DIM) + f" Loaded: {colored(loaded_file, Color.DIM)}")
            print(colored("â—‹", Color.DIM) + f" Messages: {colored(f'{len(messages)} ({len(messages)//2} turns)', Color.DIM)}")
            print()

    print_header()
    # çŠ¶æ€å±‚ - ç´§å‡‘å•è¡Œæ˜¾ç¤º
    session_status = 'continuing' if (continue_session and loaded_file) else 'new'
    status_line = (
        colored("  model:", Color.DIM) + colored(f" {model}", Color.CYAN) +
        colored("  session:", Color.DIM) + colored(f" {session_status}", Color.GREEN)
    )
    print(status_line)
    print()

    input_mode = 'normal'  # normal | box
    history = None
    # æ£€æŸ¥ç»ˆç«¯å¯ç”¨æ€§ - åŒæ—¶æ£€æŸ¥ stdin å’Œ stdout
    is_interactive = sys.stdin.isatty() or sys.stdout.isatty()
    if pt_prompt and FileHistory:
        try:
            history = FileHistory(get_input_history_path())
        except Exception:
            history = None

    def prompt_text() -> str:
        # Claude Code é£æ ¼è¾“å…¥æ¡†
        if input_mode == 'box':
            return colored("â€º ", Color.MAGENTA + Color.BOLD) + colored("[box] ", Color.DIM)
        return colored("â€º ", Color.MAGENTA + Color.BOLD)

    # ç²˜è´´è®¡æ•°å™¨ï¼ˆç”¨äºæ˜¾ç¤º [Pasted text #1 +N lines]ï¼‰
    paste_counter = [0]
    # å›¾ç‰‡é™„ä»¶çŠ¶æ€
    image_attachment = {"path": None, "selected": False}

    def read_user_message(force_box: bool = False, default_text: str = "") -> str | None:
        """è¯»å–ç”¨æˆ·è¾“å…¥ã€‚Claude Code é£æ ¼ï¼šæ”¯æŒå›¾ç‰‡é™„ä»¶é¢„è§ˆã€‚"""
        use_box = force_box or (input_mode == 'box')

        if pt_prompt and KeyBindings:
            kb = KeyBindings()
            cancel_token = "__CANCEL__"

            # é‡ç½®å›¾ç‰‡çŠ¶æ€
            image_attachment["path"] = None
            image_attachment["selected"] = False

            @kb.add('c-g')
            def _(event):
                event.app.exit(result=cancel_token)

            @kb.add('c-c')
            def _(event):
                buf = event.current_buffer
                if buf.text:
                    buf.reset()
                    return
                event.app.exit(result=cancel_token)

            @kb.add('c-s')
            def _(event):
                event.current_buffer.validate_and_handle()

            # å›¾ç‰‡é€‰æ‹©ï¼šâ†‘ é€‰æ‹©å›¾ç‰‡ï¼Œâ†“ å–æ¶ˆé€‰æ‹©
            @kb.add('up')
            def _(event):
                if image_attachment["path"]:
                    image_attachment["selected"] = True
                    # åˆ·æ–°ç•Œé¢
                    if hasattr(event.app, 'renderer'):
                        event.app.renderer.clear()

            @kb.add('down')
            def _(event):
                if image_attachment["path"]:
                    image_attachment["selected"] = False
                    # åˆ·æ–°ç•Œé¢
                    if hasattr(event.app, 'renderer'):
                        event.app.renderer.clear()

            @kb.add('enter')
            def _(event):
                buf = event.current_buffer
                text = buf.text

                # Claude Code é£æ ¼ï¼šè¡Œæœ« \ ç»§ç»­æ¢è¡Œï¼Œå¦åˆ™ Enter ç›´æ¥å‘é€
                if text.endswith('\\'):
                    buf.delete_before_cursor(count=1)
                    buf.insert_text('\n')
                    return

                buf.validate_and_handle()

            prompt_obj = PTANSI(prompt_text()) if PTANSI else prompt_text()

            # å ä½æç¤ºæ–‡å­—
            placeholder_text = HTML('<style fg="ansibrightblack">Type message or :help for commands</style>') if HTML else None

            # åº•éƒ¨çŠ¶æ€æ ï¼ˆåŒ…å«å›¾ç‰‡ä¿¡æ¯ï¼‰
            def get_toolbar():
                msg_count = len(messages)
                turns = msg_count // 2
                stream_status = "stream on" if use_stream else "stream off"

                # å›¾ç‰‡ä¿¡æ¯
                image_info = ""
                if image_attachment["path"]:
                    filename = Path(image_attachment["path"]).name
                    status = "âœ“" if image_attachment["selected"] else " "
                    image_info = f"  [{status} Image: {filename} (â†‘/â†“ to toggle)]"

                return HTML(f'<style fg="ansibrightblack">  {model}  Â·  {turns} turns  Â·  {stream_status}{image_info}</style>')

            toolbar_func = get_toolbar if HTML else None

            # å®æ—¶åˆ·æ–°çš„ rpromptï¼ˆæ˜¾ç¤ºå›¾ç‰‡æç¤ºï¼‰
            def get_rprompt():
                if image_attachment["path"] and not image_attachment["selected"]:
                    return "æŒ‰â†‘ to select"
                return None

            try:
                text = pt_prompt(
                    prompt_obj,
                    default=default_text,
                    multiline=True,
                    key_bindings=kb,
                    history=history,
                    wrap_lines=True,
                    placeholder=placeholder_text,
                    bottom_toolbar=toolbar_func,
                    rprompt=get_rprompt,
                )
            except KeyboardInterrupt:
                return None
            if text == cancel_token:
                return None

            text = sanitize_terminal_paste(text)

            # å¦‚æœæœ‰é€‰ä¸­çš„å›¾ç‰‡ï¼Œåœ¨æ–‡æœ¬æœ«å°¾æ·»åŠ å›¾ç‰‡æ ‡è®°
            if image_attachment["selected"] and image_attachment["path"]:
                text = text + f" [Image: {image_attachment['path']}]"

            return text

        prompt = readline_safe_prompt(prompt_text())
        cont_prompt = readline_safe_prompt(colored("...> ", Color.BOLD))

        # ç¡®ä¿æç¤ºç¬¦æ˜¾ç¤º
        sys.stdout.flush()

        if use_box:
            print(colored("è¾“å…¥æ¡†æ¨¡å¼ï¼šè¾“å…¥å¤šè¡Œï¼Œå•ç‹¬ä¸€è¡Œè¾“å…¥ . ç»“æŸï¼›ç©ºå†…å®¹å–æ¶ˆã€‚", Color.YELLOW))
            lines: list[str] = []
            while True:
                try:
                    l = input(cont_prompt)
                except KeyboardInterrupt:
                    return None
                if l == '.':
                    break
                lines.append(l)
            text = "\n".join(lines)
            text = sanitize_terminal_paste(text)
            return text if text.strip() else None

        try:
            line = input(prompt)
        except KeyboardInterrupt:
            return None
        lines = []
        while True:
            if line.endswith('\\'):
                lines.append(line[:-1])
                try:
                    line = input(cont_prompt)
                except KeyboardInterrupt:
                    return None
                continue
            lines.append(line)
            break
        return sanitize_terminal_paste("\n".join(lines))

    def maybe_confirm_box(text: str) -> str | None:
        show = (input_mode == 'box') or ('\n' in text) or (len(text) >= 400)
        if not show:
            return text

        while True:
            print_box("å†…å®¹", text)
            ans = input("å‘é€ï¼Ÿ[Enter]=å‘é€, e=ç¼–è¾‘, c=å–æ¶ˆ > ").strip().lower()
            if ans in {'', 'y', 'yes'}:
                return text
            if ans in {'c', 'cancel', 'n', 'no'}:
                return None
            if ans in {'e', 'edit'}:
                edited = read_user_message(force_box=True, default_text=text)
                if edited is None:
                    return None
                text = edited
                continue

    while True:
        try:
            user_input_raw = read_user_message()
            if user_input_raw is None:
                continue

            # æå–å›¾ç‰‡é™„ä»¶ [Image: /path/to/image.png]
            import re
            image_match = re.search(r'\[Image:\s*(.+?)\]', user_input_raw)
            image_path = None
            if image_match:
                image_path = image_match.group(1).strip()
                user_input_raw = re.sub(r'\s*\[Image:\s*.+?\]', '', user_input_raw)

            user_input = user_input_raw.strip()

            if user_input in [':paste', '/paste']:
                pasted = read_user_message(force_box=True)
                if pasted is None:
                    continue
                user_input = pasted.strip()


            if not user_input:
                continue

            # å¤„ç†å‘½ä»¤ï¼ˆä»¥ : æˆ– / å¼€å¤´ï¼‰
            # ä¸ºäº†åŒºåˆ†å‘½ä»¤å’Œæ–‡ä»¶è·¯å¾„ï¼Œæ£€æŸ¥æ˜¯å¦æ˜¯æœ‰æ•ˆå‘½ä»¤
            is_command = False
            cmd_prefix = None

            if user_input.startswith(':'):
                is_command = True
                cmd_prefix = ':'
            elif user_input.startswith('/'):
                # æ£€æŸ¥æ˜¯å¦æ˜¯å·²çŸ¥å‘½ä»¤ï¼ˆè€Œéæ–‡ä»¶è·¯å¾„ï¼‰
                first_word = user_input[1:].split()[0].lower() if len(user_input) > 1 else ''
                known_commands = ['quit', 'q', 'exit', 'help', 'h', 'clear', 'c', 'history', 'read', 'write', 'img', 'sessions', 'save', 'load', 'model', 'backend', 'stream', 'spinner', 'mode', 'prefs', 'status', 'paste']
                if first_word in known_commands:
                    is_command = True
                    cmd_prefix = '/'

            if is_command:
                cmd_parts = user_input[1:].split(maxsplit=1)
                cmd = cmd_parts[0].lower()
                cmd_arg = cmd_parts[1] if len(cmd_parts) > 1 else None

                if cmd in ['quit', 'q', 'exit']:
                    auto_save_history(messages, model)
                    print(colored("  bye.", Color.DIM))
                    break
                elif cmd in ['help', 'h']:
                    print_help()
                elif cmd in ['clear', 'c']:
                    if messages:
                        msg_count = len(messages)
                        round_count = msg_count // 2
                        print(colored(f"ğŸ—‘ï¸  å·²æ¸…ç©º {msg_count} æ¡æ¶ˆæ¯ ({round_count} è½®å¯¹è¯)", Color.YELLOW))
                        print(colored("   ä¸Šä¸‹æ–‡å·²é‡ç½®ï¼Œå¼€å§‹æ–°çš„å¯¹è¯", Color.YELLOW))
                        messages = []
                    else:
                        print(colored("å¯¹è¯å†å²æœ¬æ¥å°±æ˜¯ç©ºçš„", Color.YELLOW))
                elif cmd == 'history':
                    if not messages:
                        print(colored("å¯¹è¯å†å²ä¸ºç©º", Color.YELLOW))
                    else:
                        for i, msg in enumerate(messages):
                            role = "You" if msg["role"] == "user" else "AI"
                            content = msg["content"][:100] + "..." if len(msg["content"]) > 100 else msg["content"]
                            print(f"  [{i+1}] {role}: {content}")
                elif cmd == 'model':
                    if cmd_arg:
                        model = resolve_model(cmd_arg)
                        print(colored(f"â†’ {model}", Color.GREEN))
                    else:
                        print(f"å½“å‰æ¨¡å‹: {model}")
                        print(f"å¯ç”¨æ¨¡å‹: flash, pro, pro3")
                elif cmd == 'backend':
                    command_name = os.path.basename(sys.argv[0])
                    print(f"å½“å‰å‘½ä»¤: {command_name}")
                    print(f"å½“å‰åç«¯: {backend_config['name']}")
                    print(f"ç¯å¢ƒå˜é‡: {command_name.upper()}_BASE_URL, {command_name.upper()}_KEY")
                elif cmd == 'status':
                    turns = len(messages) // 2
                    stream_status = "on" if use_stream else "off"
                    spinner_status = "on" if show_spinner else "off"
                    tools_status = ', '.join([t['name'] for t in enabled_tools]) if enabled_tools else "-"
                    prefs_status = "on" if preferences else "off"
                    print(colored(f"  {model}  Â·  {turns} turns  Â·  stream {stream_status}  Â·  spinner {spinner_status}  Â·  prefs {prefs_status}", Color.DIM))
                elif cmd in {'prefs', 'preferences'}:
                    # ç®¡ç†åå¥½æ–‡ä»¶
                    prefs_path = get_preferences_path()
                    if cmd_arg == 'edit':
                        # ç”¨é»˜è®¤ç¼–è¾‘å™¨æ‰“å¼€
                        editor = os.environ.get('EDITOR', 'vim')
                        os.makedirs(os.path.dirname(prefs_path), exist_ok=True)
                        if not os.path.exists(prefs_path):
                            # åˆ›å»ºæ¨¡æ¿
                            with open(prefs_path, 'w', encoding='utf-8') as f:
                                f.write("# GCHAT åå¥½è®¾ç½®\n\n")
                                f.write("# è¿™ä¸ªæ–‡ä»¶çš„å†…å®¹ä¼šä½œä¸ºç³»ç»Ÿæç¤ºå‘é€ç»™ AI\n")
                                f.write("# ä½ å¯ä»¥åœ¨è¿™é‡Œè®¾ç½®ï¼š\n")
                                f.write("# - åå¥½çš„å›å¤é£æ ¼\n")
                                f.write("# - å¸¸ç”¨çš„ä¸Šä¸‹æ–‡ä¿¡æ¯\n")
                                f.write("# - é¡¹ç›®ç›¸å…³çš„è¯´æ˜\n\n")
                        os.system(f'{editor} "{prefs_path}"')
                        # é‡æ–°åŠ è½½
                        preferences = load_preferences()
                        if preferences:
                            # æ›´æ–° messages ä¸­çš„ system æ¶ˆæ¯
                            messages = [m for m in messages if m.get("role") != "system" or "[å¯¹è¯å†å²æ‘˜è¦]" in m.get("content", "")]
                            messages.insert(0, {"role": "system", "content": preferences})
                            print(colored("â†’ preferences reloaded", Color.GREEN))
                    elif cmd_arg == 'show':
                        if os.path.exists(prefs_path):
                            with open(prefs_path, 'r', encoding='utf-8') as f:
                                content = f.read()
                            print(colored("â”€" * 40, Color.DIM))
                            print(content)
                            print(colored("â”€" * 40, Color.DIM))
                        else:
                            print(colored("  no preferences file", Color.DIM))
                    elif cmd_arg == 'path':
                        print(colored(f"  {prefs_path}", Color.DIM))
                    else:
                        prefs_exists = os.path.exists(prefs_path)
                        print(colored(f"â†’ prefs: {'on' if prefs_exists else 'off'}", Color.GREEN if prefs_exists else Color.DIM))
                        print(colored(f"  path: {prefs_path}", Color.DIM))
                        print(colored("  /prefs edit  - ç¼–è¾‘åå¥½æ–‡ä»¶", Color.DIM))
                        print(colored("  /prefs show  - æ˜¾ç¤ºå½“å‰å†…å®¹", Color.DIM))
                elif cmd == 'sessions':
                    # åˆ—å‡ºæ‰€æœ‰ä¼šè¯
                    sessions = list_sessions()
                    if sessions:
                        print(colored("ä¿å­˜çš„ä¼šè¯:", Color.GREEN))
                        for i, s in enumerate(sessions[:10]):  # æœ€å¤šæ˜¾ç¤º10ä¸ª
                            ts = s["timestamp"]
                            if ts:
                                ts = f"{ts[:4]}-{ts[4:6]}-{ts[6:8]} {ts[9:11]}:{ts[11:13]}"
                            print(f"  [{i+1}] {ts} | {s['model']} | {s['msg_count']}æ¡ | {s['preview']}")
                        if len(sessions) > 10:
                            print(colored(f"  ... è¿˜æœ‰ {len(sessions) - 10} ä¸ªä¼šè¯", Color.DIM))
                        print(colored("\nä½¿ç”¨ /load <ç¼–å·> åŠ è½½ä¼šè¯", Color.YELLOW))
                elif cmd == 'read':
                    # è¯»å–æ–‡ä»¶
                    if not cmd_arg:
                        print(colored("ç”¨æ³•: /read <æ–‡ä»¶è·¯å¾„>", Color.YELLOW))
                        continue
                    file_result, error = read_file_content(cmd_arg)
                    if error:
                        print(colored(error, Color.RED))
                        continue
                    if file_result["type"] == "image":
                        # å›¾ç‰‡æ–‡ä»¶ï¼Œè½¬åˆ°å›¾ç‰‡å¤„ç†
                        print(colored(f"ğŸ“· æ£€æµ‹åˆ°å›¾ç‰‡: {file_result['path']}", Color.CYAN))
                        user_message = {
                            "role": "user",
                            "content": [
                                {"type": "text", "text": "è¯·æè¿°è¿™å¼ å›¾ç‰‡ã€‚"},
                                {"type": "image_file", "path": file_result["path"]}
                            ],
                        }
                    else:
                        # æ–‡æœ¬æ–‡ä»¶
                        content = file_result["content"]
                        file_path = file_result["path"]
                        line_count = content.count('\n') + 1
                        print(colored(f"ğŸ“„ å·²è¯»å–: {file_path} ({line_count} è¡Œ)", Color.CYAN))
                        user_message = {
                            "role": "user",
                            "content": f"è¯·åˆ†æä»¥ä¸‹æ–‡ä»¶å†…å®¹:\n\næ–‡ä»¶: {file_path}\n\n```\n{content}\n```"
                        }
                    messages.append(user_message)
                    print()  # AI response follows
                    # verbose æ¨¡å¼ä¸‹æ˜¾ç¤º API è°ƒç”¨ä¿¡æ¯
                    if verbose:
                        backend_display = backend_config.get('name', 'Unknown')
                        print(colored(f"â†’ {model} Â· {backend_display} Â· Thinking...", Color.DIM))
                    if use_stream:
                        response = chat_request_with_fallback_stream(messages, model, backend_config, show_spinner=show_spinner)
                    else:
                        response = chat_request_with_fallback(messages, model, backend_config, show_spinner=show_spinner)
                        print(response)
                    print()
                    messages.append({"role": "assistant", "content": response})
                elif cmd == 'write':
                    # å†™å…¥æ–‡ä»¶
                    if not cmd_arg:
                        print(colored("ç”¨æ³•: /write <æ–‡ä»¶è·¯å¾„>", Color.YELLOW))
                        continue
                    if not messages:
                        print(colored("æ²¡æœ‰å¯ä¿å­˜çš„å†…å®¹", Color.YELLOW))
                        continue
                    # è·å–æœ€åä¸€æ¡AIå›å¤
                    last_response = None
                    for msg in reversed(messages):
                        if msg.get("role") == "assistant":
                            last_response = msg.get("content", "")
                            break
                    if not last_response:
                        print(colored("æ²¡æœ‰AIå›å¤å¯ä¿å­˜", Color.YELLOW))
                        continue
                    success, result = write_to_file(cmd_arg, last_response)
                    if success:
                        print(colored(f"âœ… å·²ä¿å­˜åˆ°: {result}", Color.GREEN))
                    else:
                        print(colored(f"âŒ ä¿å­˜å¤±è´¥: {result}", Color.RED))
                elif cmd == 'stream':
                    # åˆ‡æ¢æµå¼è¾“å‡º
                    use_stream = not use_stream
                    print(colored(f"â†’ stream {'on' if use_stream else 'off'}", Color.GREEN))
                elif cmd == 'spinner':
                    # åˆ‡æ¢ spinner åŠ¨ç”»
                    show_spinner = not show_spinner
                    print(colored(f"â†’ spinner {'on' if show_spinner else 'off'}", Color.GREEN))
                elif cmd == 'tools':
                    if not cmd_arg:
                        # åˆ—å‡ºå½“å‰å¯ç”¨çš„å·¥å…·
                        if enabled_tools:
                            names = [t['name'] for t in enabled_tools]
                            print(colored(f"â†’ tools: {', '.join(names)}", Color.GREEN))
                        else:
                            print(colored("â†’ tools: none", Color.DIM))
                            print(colored(f"  available: {', '.join(BUILTIN_TOOLS.keys())}", Color.DIM))
                    else:
                        parts = cmd_arg.split(maxsplit=1)
                        subcmd = parts[0].lower()
                        subarg = parts[1] if len(parts) > 1 else None

                        if subcmd == 'list':
                            for name, tool in BUILTIN_TOOLS.items():
                                status = "+" if any(t['name'] == tool['name'] for t in enabled_tools) else " "
                                print(colored(f"  {status} {name}", Color.GREEN if status == "+" else Color.DIM))
                        elif subcmd == 'add':
                            if subarg and subarg in BUILTIN_TOOLS:
                                tool = BUILTIN_TOOLS[subarg]
                                if not any(t['name'] == tool['name'] for t in enabled_tools):
                                    enabled_tools.append(tool)
                                    print(colored(f"+ {tool['name']}", Color.GREEN))
                                else:
                                    print(colored(f"  {subarg} already enabled", Color.DIM))
                            else:
                                print(colored(f"  unknown: {subarg}", Color.RED))
                        elif subcmd == 'remove':
                            if subarg:
                                tool = BUILTIN_TOOLS.get(subarg)
                                if tool:
                                    enabled_tools = [t for t in enabled_tools if t['name'] != tool['name']]
                                    print(colored(f"- {tool['name']}", Color.YELLOW))
                                else:
                                    print(colored(f"  unknown: {subarg}", Color.RED))
                            else:
                                print(colored("  usage: /tools remove <name>", Color.DIM))
                        elif subcmd == 'clear':
                            enabled_tools = []
                            print(colored("â†’ tools cleared", Color.YELLOW))
                        else:
                            print(colored("  usage: /tools [list|add|remove|clear]", Color.DIM))
                elif cmd == 'call':
                    # å¼ºåˆ¶ä½¿ç”¨å®˜æ–¹APIè¿›è¡ŒFunction Calling
                    if not cmd_arg:
                        print("ç”¨æ³•: /call <æç¤ºè¯>")
                        continue

                    if not enabled_tools:
                        print(colored("âš ï¸  æ²¡æœ‰å¯ç”¨ä»»ä½•å·¥å…·ï¼Œè¯·å…ˆä½¿ç”¨ /tools add <name> æ·»åŠ å·¥å…·", Color.YELLOW))
                        continue

                    print(colored(f"ğŸ”§ ä½¿ç”¨å®˜æ–¹APIè¿›è¡ŒFunction Calling...", Color.CYAN))
                    messages.append({"role": "user", "content": cmd_arg})

                    result, error = official_api_request(messages, model, enabled_tools)
                    if error:
                        print(colored(error, Color.RED))
                        messages.pop()  # ç§»é™¤å¤±è´¥çš„æ¶ˆæ¯
                        continue

                    if result["type"] == "function_call":
                        fc_name = result["name"]
                        fc_args = result["args"]
                        print(colored(f"ğŸ“ å‡½æ•°è°ƒç”¨: {fc_name}({json.dumps(fc_args, ensure_ascii=False)})", Color.YELLOW))

                        # æ‰§è¡Œå‡½æ•°
                        fc_result = execute_function(fc_name, fc_args)
                        print(colored(f"ğŸ“¤ å‡½æ•°ç»“æœ: {json.dumps(fc_result, ensure_ascii=False)}", Color.GREEN))

                        # è®°å½•åˆ°å†å²
                        messages.append({"role": "assistant", "content": f"[è°ƒç”¨å‡½æ•° {fc_name}]\nå‚æ•°: {json.dumps(fc_args, ensure_ascii=False)}\nç»“æœ: {json.dumps(fc_result, ensure_ascii=False)}"})
                    else:
                        print()  # AI response follows
                        print(result["content"])
                        messages.append({"role": "assistant", "content": result["content"]})
                    print()
                elif cmd == 'save':
                    if cmd_arg:
                        try:
                            with open(cmd_arg, 'w', encoding='utf-8') as f:
                                json.dump({"model": model, "messages": messages}, f, ensure_ascii=False, indent=2)
                            print(colored(f"å¯¹è¯å·²ä¿å­˜åˆ°: {cmd_arg}", Color.GREEN))
                        except Exception as e:
                            print(colored(f"ä¿å­˜å¤±è´¥: {e}", Color.RED))
                    else:
                        print("ç”¨æ³•: /save <æ–‡ä»¶å>")
                elif cmd == 'load':
                    if cmd_arg:
                        try:
                            with open(cmd_arg, 'r', encoding='utf-8') as f:
                                data = json.load(f)
                                messages = data.get("messages", [])
                                model = data.get("model", model)
                            print(colored(f"å¯¹è¯å·²åŠ è½½ï¼Œå…± {len(messages)} æ¡æ¶ˆæ¯", Color.GREEN))
                        except Exception as e:
                            print(colored(f"åŠ è½½å¤±è´¥: {e}", Color.RED))
                    else:
                        print("ç”¨æ³•: /load <æ–‡ä»¶å>")
                elif cmd == 'mode':
                    if not cmd_arg:
                        input_mode = 'box' if input_mode == 'normal' else 'normal'
                    else:
                        arg = cmd_arg.strip().lower()
                        if arg in {'normal', 'n'}:
                            input_mode = 'normal'
                        elif arg in {'box', 'b'}:
                            input_mode = 'box'
                        else:
                            print(colored("ç”¨æ³•: /mode [normal|box]", Color.YELLOW))
                            continue
                    print(colored(f"â†’ {input_mode}", Color.GREEN))
                elif cmd in {'img', 'image'}:
                    try:
                        parts = shlex.split(user_input, posix=True)
                    except ValueError as e:
                        print(colored(f"å‚æ•°è§£æå¤±è´¥: {e}", Color.RED))
                        continue

                    args = parts[1:]
                    if not args:
                        print(colored("ç”¨æ³•: /img <å›¾ç‰‡è·¯å¾„...> [æè¿°æ–‡æœ¬]", Color.YELLOW))
                        continue

                    # ä½¿ç”¨è´ªå©ªåˆå¹¶é€»è¾‘å¤„ç†å¸¦ç©ºæ ¼çš„å›¾ç‰‡è·¯å¾„
                    image_paths: list[Path] = []
                    text_parts: list[str] = []
                    i = 0

                    while i < len(args):
                        tok = args[i]

                        # å¦‚æœ token ä»¥ / æˆ– ~ å¼€å¤´ï¼Œå¯èƒ½æ˜¯è·¯å¾„çš„å¼€å§‹
                        if tok.startswith('/') or tok.startswith('~'):
                            # è´ªå©ªåœ°å°è¯•åˆå¹¶åç»­ tokensï¼Œæ‰¾åˆ°æœ€é•¿çš„æœ‰æ•ˆå›¾ç‰‡è·¯å¾„
                            found_image = None
                            merged_count = 0

                            for j in range(i, len(args)):
                                candidate = ' '.join(args[i:j+1])
                                p = Path(candidate).expanduser()

                                if is_image_file(p):
                                    found_image = p
                                    merged_count = j - i + 1

                            if found_image:
                                image_paths.append(found_image)
                                i += merged_count
                                continue

                        # ä¸æ˜¯å›¾ç‰‡è·¯å¾„ï¼ŒåŠ å…¥æ–‡æœ¬éƒ¨åˆ†
                        text_parts.append(tok)
                        i += 1

                    if not image_paths:
                        print(colored("æœªæ£€æµ‹åˆ°æœ‰æ•ˆå›¾ç‰‡æ–‡ä»¶ï¼ˆæ”¯æŒ png/jpg/jpeg/webp/gif ç­‰ï¼‰", Color.YELLOW))
                        continue

                    user_text = " ".join(text_parts).strip() or "è¯·æè¿°è¿™å¼ å›¾ç‰‡ã€‚"
                    confirmed_text = maybe_confirm_box(user_text)
                    if confirmed_text is None:
                        continue

                    user_message = {
                        "role": "user",
                        "content": [{"type": "text", "text": confirmed_text}] + [
                            {"type": "image_file", "path": str(p)} for p in image_paths
                        ],
                    }
                    messages.append(user_message)

                    print()  # AI response follows
                    response = chat_request_with_fallback(messages, model, backend_config)
                    print(response)
                    print()
                    messages.append({"role": "assistant", "content": response})
                else:
                    print(colored(f"æœªçŸ¥å‘½ä»¤: :{cmd}ï¼Œè¾“å…¥ :help æŸ¥çœ‹å¸®åŠ©", Color.RED))
                continue

            # å›¾ç‰‡ï¼šæ”¯æŒç›´æ¥æ‹–æ‹½å›¾ç‰‡è·¯å¾„åˆ°è¾“å…¥æ¡†ï¼Œæˆ–é€šè¿‡ [Image: ...] æ ‡è®°
            cleaned_text, image_paths = extract_local_image_paths(user_input)

            # å¦‚æœæœ‰é€šè¿‡æ–¹å‘é”®é€‰æ‹©çš„å›¾ç‰‡
            if image_path:
                image_paths.insert(0, Path(image_path))

            if image_paths:
                user_text = cleaned_text or "è¯·æè¿°è¿™å¼ å›¾ç‰‡ã€‚"
                confirmed_text = maybe_confirm_box(user_text)
                if confirmed_text is None:
                    continue
                messages.append({
                    "role": "user",
                    "content": [{"type": "text", "text": confirmed_text}] + [
                        {"type": "image_file", "path": str(p)} for p in image_paths
                    ],
                })
            else:
                confirmed_text = maybe_confirm_box(user_input)
                if confirmed_text is None:
                    continue
                messages.append({"role": "user", "content": confirmed_text})

            # å‘é€è¯·æ±‚ - æ··åˆè·¯ç”±é€»è¾‘
            sys.stdout.write("\n")
            sys.stdout.flush()

            # ä¸Šä¸‹æ–‡å‹ç¼© - å½“æ¶ˆæ¯è¿‡å¤šæ—¶è‡ªåŠ¨æ‘˜è¦
            messages, compressed = compress_context(messages, backend_config, model)
            if compressed:
                print(colored("â—‹ context compressed", Color.DIM))

            # å·¥å…·è°ƒç”¨æš‚ä¸æ”¯æŒï¼ˆç®€åŒ–é…ç½®åï¼‰
            # if enabled_tools and backend_config.get("supports_tools"):
            #     result, error = openai_tools_request(messages, model, enabled_tools, backend_config)

            # æ™®é€šè¯·æ±‚
            if use_stream:
                response = chat_request_with_fallback_stream(messages, model, backend_config, show_spinner=show_spinner)
            else:
                response = chat_request_with_fallback(messages, model, backend_config)
                print(response)

            print()

            # æ·»åŠ AIå›å¤åˆ°å†å²
            messages.append({"role": "assistant", "content": response})

        except KeyboardInterrupt:
            # å®æ—¶ä¸­æ–­ï¼šä¿å­˜ä¸Šä¸‹æ–‡
            print("\n" + colored("ğŸ’¾ å·²ä¿å­˜ä¸Šä¸‹æ–‡ï¼ŒæŒ‰ Enter ç»§ç»­æˆ– /q é€€å‡º", Color.YELLOW))
            auto_save_history(messages, model)
        except EOFError:
            print()
            auto_save_history(messages, model)
            print(colored("  bye.", Color.DIM))
            break


def upload_to_r2(image_data: bytes, filename: str) -> str:
    """ä¸Šä¼ å›¾ç‰‡åˆ° Cloudflare R2ï¼Œè¿”å›å…¬å¼€URL"""
    try:
        import boto3
        from botocore.config import Config
    except ImportError:
        return "[é”™è¯¯] éœ€è¦å®‰è£… boto3: pip install boto3"

    s3 = boto3.client(
        's3',
        endpoint_url=R2_CONFIG["endpoint"],
        aws_access_key_id=R2_CONFIG["access_key_id"],
        aws_secret_access_key=R2_CONFIG["secret_access_key"],
        config=Config(signature_version='s3v4'),
        region_name='auto'
    )

    # è·¯å¾„æ ¼å¼: nexusai/img/gchat_YYYYMMDD_HHMMSS.png
    key = f"nexusai/img/{filename}"

    try:
        s3.put_object(
            Bucket=R2_CONFIG["bucket"],
            Key=key,
            Body=image_data,
            ContentType='image/png'
        )
        return f"{R2_CONFIG['public_url']}/{key}"
    except Exception as e:
        return f"[R2ä¸Šä¼ å¤±è´¥] {e}"


def _generate_image_zyai(prompt: str, model: str) -> tuple[bytes, str] | tuple[None, str]:
    """ä½¿ç”¨ ZYAI (Gemini Native API) ç”Ÿæˆå›¾ç‰‡"""
    import urllib.request
    import urllib.error

    url = ZYAI_IMAGE_CONFIG["url"].replace("{model}", model)
    headers = {
        "Authorization": f"Bearer {ZYAI_IMAGE_CONFIG['key']}",
        "Content-Type": "application/json"
    }
    # Gemini Native API æ ¼å¼
    data = json.dumps({
        "contents": [{"parts": [{"text": prompt}]}],
        "generationConfig": {"responseModalities": ["TEXT", "IMAGE"]}
    }).encode('utf-8')

    req = urllib.request.Request(url, data=data, headers=headers, method='POST')

    try:
        with urllib.request.urlopen(req, timeout=120) as response:
            result = json.loads(response.read().decode('utf-8'))

            # Gemini Native API å“åº”æ ¼å¼
            # {"candidates": [{"content": {"parts": [{"inlineData": {"mimeType": "image/png", "data": "..."}}]}}]}
            if "candidates" in result:
                for candidate in result["candidates"]:
                    parts = candidate.get("content", {}).get("parts", [])
                    for part in parts:
                        inline_data = part.get("inlineData", {})
                        if inline_data.get("data"):
                            return base64.b64decode(inline_data["data"]), ""

            return None, f"[ZYAIå“åº”å¼‚å¸¸] {json.dumps(result, ensure_ascii=False)[:200]}"

    except urllib.error.HTTPError as e:
        error_body = e.read().decode('utf-8') if e.fp else str(e)
        return None, f"[ZYAI HTTP {e.code}] {error_body[:200]}"
    except Exception as e:
        return None, f"[ZYAIé”™è¯¯] {e}"


def _generate_image_nexusai(prompt: str, model: str) -> tuple[bytes, str] | tuple[None, str]:
    """ä½¿ç”¨ NexusAI (OpenAIæ ¼å¼) ç”Ÿæˆå›¾ç‰‡"""
    import urllib.request
    import urllib.error

    url = NEXUSAI_IMAGE_CONFIG["url"]
    headers = {
        "Authorization": f"Bearer {NEXUSAI_IMAGE_CONFIG['key']}",
        "Content-Type": "application/json"
    }
    data = json.dumps({
        "model": model,
        "prompt": prompt,
        "n": 1,
        "response_format": "b64_json"
    }).encode('utf-8')

    req = urllib.request.Request(url, data=data, headers=headers, method='POST')

    try:
        with urllib.request.urlopen(req, timeout=120) as response:
            result = json.loads(response.read().decode('utf-8'))

            # æ ¼å¼1: {"images": ["data:image/png;base64,..."]}
            if "images" in result and len(result["images"]) > 0:
                data_url = result["images"][0]
                if data_url.startswith("data:"):
                    b64_data = data_url.split(",", 1)[1] if "," in data_url else data_url
                    return base64.b64decode(b64_data), ""

            # æ ¼å¼2: {"data": [{"b64_json": "..."}]}
            if "data" in result and len(result["data"]) > 0:
                item = result["data"][0]
                b64_data = item.get("b64_json")
                if b64_data:
                    return base64.b64decode(b64_data), ""

                # æ ¼å¼3: {"data": [{"url": "..."}]} - ä¸‹è½½URL
                img_url = item.get("url")
                if img_url:
                    try:
                        with urllib.request.urlopen(img_url, timeout=60) as img_resp:
                            return img_resp.read(), ""
                    except Exception as e:
                        return None, f"[NexusAIå›¾ç‰‡ä¸‹è½½å¤±è´¥] {e}"

            return None, f"[NexusAIå“åº”å¼‚å¸¸] {json.dumps(result, ensure_ascii=False)[:200]}"

    except urllib.error.HTTPError as e:
        error_body = e.read().decode('utf-8') if e.fp else str(e)
        return None, f"[NexusAI HTTP {e.code}] {error_body[:200]}"
    except Exception as e:
        return None, f"[NexusAIé”™è¯¯] {e}"


def _generate_image_gptload(prompt: str, model: str) -> tuple[bytes, str] | tuple[None, str]:
    """ä½¿ç”¨ GPT-Load (Cookieæ¨¡å¼ï¼Œæ— é¢åº¦é™åˆ¶) ç”Ÿæˆå›¾ç‰‡"""
    import urllib.request
    import urllib.error

    url = GPTLOAD_IMAGE_CONFIG["url"]
    headers = {
        "Authorization": f"Bearer {GPTLOAD_IMAGE_CONFIG['key']}",
        "Content-Type": "application/json"
    }
    data = json.dumps({
        "model": model,
        "prompt": prompt,
        "n": 1,
        "response_format": "b64_json"
    }).encode('utf-8')

    req = urllib.request.Request(url, data=data, headers=headers, method='POST')

    try:
        with urllib.request.urlopen(req, timeout=120) as response:
            result = json.loads(response.read().decode('utf-8'))

            # æ ¼å¼1: {"images": ["data:image/png;base64,..."]}
            if "images" in result and len(result["images"]) > 0:
                data_url = result["images"][0]
                if data_url.startswith("data:"):
                    b64_data = data_url.split(",", 1)[1] if "," in data_url else data_url
                    return base64.b64decode(b64_data), ""

            # æ ¼å¼2: {"data": [{"b64_json": "..."}]}
            if "data" in result and len(result["data"]) > 0:
                b64_data = result["data"][0].get("b64_json")
                if b64_data:
                    return base64.b64decode(b64_data), ""

            return None, f"[GPT-Loadå“åº”å¼‚å¸¸] {json.dumps(result, ensure_ascii=False)[:200]}"

    except urllib.error.HTTPError as e:
        error_body = e.read().decode('utf-8') if e.fp else str(e)
        return None, f"[GPT-Load HTTP {e.code}] {error_body[:200]}"
    except Exception as e:
        return None, f"[GPT-Loadé”™è¯¯] {e}"


def _generate_image_yunwu(prompt: str, model: str, ref_image_b64_list: list = None) -> tuple[bytes, str] | tuple[None, str]:
    """ä½¿ç”¨ YUNWU Chat API ç”Ÿæˆå›¾ç‰‡ (chat completions with image model)

    Args:
        prompt: å›¾ç‰‡ç”Ÿæˆæç¤ºè¯
        model: å›¾ç‰‡ç”Ÿæˆæ¨¡å‹
        ref_image_b64_list: å‚è€ƒå›¾ç‰‡çš„base64ç¼–ç åˆ—è¡¨ (ç”¨äºå›¾ç”Ÿå›¾ï¼Œæœ€å¤š3å¼ )
    """
    import urllib.request
    import urllib.error
    import re

    url = YUNWU_IMAGE_CONFIG["url"]
    headers = {
        "Authorization": f"Bearer {YUNWU_IMAGE_CONFIG['key']}",
        "Content-Type": "application/json"
    }

    # æ„å»ºæ¶ˆæ¯å†…å®¹
    if ref_image_b64_list:
        # å›¾ç”Ÿå›¾æ¨¡å¼ï¼šåŒ…å«å¤šå¼ å‚è€ƒå›¾ç‰‡
        content = [
            {"type": "text", "text": prompt},
        ]
        # æ·»åŠ æ‰€æœ‰å‚è€ƒå›¾ç‰‡
        for ref_b64 in ref_image_b64_list:
            content.append({"type": "image_url", "image_url": {"url": f"data:image/png;base64,{ref_b64}"}})
    else:
        content = prompt

    # ä½¿ç”¨ chat completions æ ¼å¼ï¼Œæ¨¡å‹ä¼šè¿”å›å›¾ç‰‡
    data = json.dumps({
        "model": model,
        "messages": [{"role": "user", "content": content}],
        "max_tokens": 4096
    }).encode('utf-8')

    req = urllib.request.Request(url, data=data, headers=headers, method='POST')

    try:
        with urllib.request.urlopen(req, timeout=120) as response:
            result = json.loads(response.read().decode('utf-8'))

            # Chat completions æ ¼å¼å“åº”
            if "choices" in result and len(result["choices"]) > 0:
                msg_content = result["choices"][0].get("message", {}).get("content", "")
                content_str = str(msg_content) if not isinstance(msg_content, str) else msg_content

                # æ ¼å¼1: base64 å›¾ç‰‡æ•°æ®
                if "data:image" in content_str:
                    match = re.search(r'data:image/[^;]+;base64,([A-Za-z0-9+/=]+)', content_str)
                    if match:
                        return base64.b64decode(match.group(1)), ""

                # æ ¼å¼2: Markdown æ ¼å¼çš„å›¾ç‰‡URL ![image](url)
                match = re.search(r'!\[image\]\((https?://[^\)]+)\)', content_str)
                if match:
                    img_url = match.group(1)
                    try:
                        with urllib.request.urlopen(img_url, timeout=60) as img_resp:
                            return img_resp.read(), ""
                    except Exception as e:
                        return None, f"[YUNWUå›¾ç‰‡ä¸‹è½½å¤±è´¥] {e}"

                # æ ¼å¼3: ç›´æ¥çš„URL
                match = re.search(r'(https?://[^\s]+\.(?:png|jpg|jpeg|webp))', content_str)
                if match:
                    img_url = match.group(1)
                    try:
                        with urllib.request.urlopen(img_url, timeout=60) as img_resp:
                            return img_resp.read(), ""
                    except Exception as e:
                        return None, f"[YUNWUå›¾ç‰‡ä¸‹è½½å¤±è´¥] {e}"

            return None, f"[YUNWUå“åº”å¼‚å¸¸] {json.dumps(result, ensure_ascii=False)[:200]}"

    except urllib.error.HTTPError as e:
        error_body = e.read().decode('utf-8') if e.fp else str(e)
        return None, f"[YUNWU HTTP {e.code}] {error_body[:200]}"
    except Exception as e:
        return None, f"[YUNWUé”™è¯¯] {e}"


def _generate_image_google_api(prompt: str, model: str, ref_image_b64_list: list = None) -> tuple[bytes, str] | tuple[None, str]:
    """ä½¿ç”¨ Google API (æœ€ç»ˆé™çº§ï¼ŒCookieæ¨¡å¼æ— éœ€Key)

    Args:
        prompt: å›¾ç‰‡ç”Ÿæˆæç¤ºè¯
        model: å›¾ç‰‡ç”Ÿæˆæ¨¡å‹
        ref_image_b64_list: å‚è€ƒå›¾ç‰‡çš„base64ç¼–ç åˆ—è¡¨ (ç”¨äºå›¾ç”Ÿå›¾ï¼Œæœ€å¤š3å¼ )
    """
    import urllib.request
    import urllib.error

    url = GOOGLE_API_IMAGE_CONFIG["url"]
    headers = {
        "Content-Type": "application/json"
    }

    # æ„å»ºæ¶ˆæ¯å†…å®¹
    if ref_image_b64_list:
        # å›¾ç”Ÿå›¾æ¨¡å¼ï¼šåŒ…å«å¤šå¼ å‚è€ƒå›¾ç‰‡
        content = [
            {"type": "text", "text": prompt},
        ]
        # æ·»åŠ æ‰€æœ‰å‚è€ƒå›¾ç‰‡
        for ref_b64 in ref_image_b64_list:
            content.append({"type": "image_url", "image_url": {"url": f"data:image/png;base64,{ref_b64}"}})
    else:
        content = prompt

    # ä½¿ç”¨ chat completions æ ¼å¼
    data = json.dumps({
        "model": model,
        "messages": [{"role": "user", "content": content}],
        "max_tokens": 4096
    }).encode('utf-8')

    req = urllib.request.Request(url, data=data, headers=headers, method='POST')

    try:
        with urllib.request.urlopen(req, timeout=120) as response:
            result = json.loads(response.read().decode('utf-8'))

            # Chat completions æ ¼å¼å“åº”
            if "choices" in result and len(result["choices"]) > 0:
                msg_content = result["choices"][0].get("message", {}).get("content", "")
                # æ£€æŸ¥æ˜¯å¦åŒ…å« base64 å›¾ç‰‡æ•°æ®
                if "data:image" in str(msg_content):
                    import re
                    content_str = str(msg_content) if not isinstance(msg_content, str) else msg_content
                    match = re.search(r'data:image/[^;]+;base64,([A-Za-z0-9+/=]+)', content_str)
                    if match:
                        return base64.b64decode(match.group(1)), ""

            return None, f"[Google-APIå“åº”å¼‚å¸¸] {json.dumps(result, ensure_ascii=False)[:200]}"

    except urllib.error.HTTPError as e:
        error_body = e.read().decode('utf-8') if e.fp else str(e)
        return None, f"[Google-API HTTP {e.code}] {error_body[:200]}"
    except Exception as e:
        return None, f"[Google-APIé”™è¯¯] {e}"


def generate_image(prompt: str, model: str = DEFAULT_IMAGE_MODEL, ref_image_b64_list: list = None) -> tuple[bytes, str, str] | tuple[None, str, str]:
    """ç”Ÿæˆå›¾ç‰‡ (å¤šAPIé™çº§ï¼šGPT-Load -> YUNWU -> ZYAI -> NexusAI -> Google-API)

    Args:
        prompt: å›¾ç‰‡ç”Ÿæˆæç¤ºè¯
        model: å›¾ç‰‡ç”Ÿæˆæ¨¡å‹
        ref_image_b64_list: å‚è€ƒå›¾ç‰‡çš„base64ç¼–ç åˆ—è¡¨ (ç”¨äºå›¾ç”Ÿå›¾ï¼Œæœ€å¤š3å¼ )

    è¿”å›: (å›¾ç‰‡æ•°æ®, ç”Ÿæˆæº, é”™è¯¯ä¿¡æ¯)
    """
    errors = []

    # å¦‚æœæœ‰å‚è€ƒå›¾ç‰‡ï¼Œä½¿ç”¨æ”¯æŒå›¾ç”Ÿå›¾çš„APIé™çº§é“¾
    if ref_image_b64_list:
        # 1. ä¼˜å…ˆä½¿ç”¨ YUNWU (æœ‰ä½™é¢ï¼Œchat completionsæ”¯æŒå›¾ç”Ÿå›¾)
        image_data, error = _generate_image_yunwu(prompt, model, ref_image_b64_list)
        if image_data:
            return image_data, "YUNWU", ""
        errors.append(f"YUNWU: {error}")

        # 2. é™çº§åˆ° Google-API (chat completionsæ”¯æŒå›¾ç”Ÿå›¾)
        image_data, error = _generate_image_google_api(prompt, model, ref_image_b64_list)
        if image_data:
            return image_data, "Google-API", ""
        errors.append(f"Google-API: {error}")

        # 3. æœ€ç»ˆé™çº§ï¼šGoogle ä¸“ç”¨å›¾ç‰‡ç¼–è¾‘ç«¯ç‚¹ (/v1/images/edit)
        # æ³¨æ„ï¼šä¸“ç”¨ç«¯ç‚¹åªæ”¯æŒå•å›¾ï¼Œä½¿ç”¨ç¬¬ä¸€å¼ 
        image_data, error = _generate_image_google_dedicated(prompt, ref_image_b64_list[0])
        if image_data:
            return image_data, "Google-Edit", ""
        errors.append(f"Google-Edit: {error}")

        return None, "", f"å›¾ç”Ÿå›¾å¤±è´¥: {' | '.join(errors)}"

    # 1. å…ˆå°è¯• GPT-Load (Cookieæ¨¡å¼ï¼Œæ— é¢åº¦é™åˆ¶)
    image_data, error = _generate_image_gptload(prompt, model)
    if image_data:
        return image_data, "GPT-Load", ""
    errors.append(error)

    # 2. å°è¯• YUNWU
    image_data, error = _generate_image_yunwu(prompt, model)
    if image_data:
        return image_data, "YUNWU", ""
    errors.append(error)

    # 3. å°è¯• ZYAI
    image_data, error = _generate_image_zyai(prompt, model)
    if image_data:
        return image_data, "ZYAI", ""
    errors.append(error)

    # 4. å°è¯• NexusAI
    image_data, error = _generate_image_nexusai(prompt, model)
    if image_data:
        return image_data, "NexusAI", ""
    errors.append(error)

    # 5. æœ€ç»ˆé™çº§ï¼šGoogle ä¸“ç”¨å›¾ç‰‡ç”Ÿæˆç«¯ç‚¹ (/v1/generate-images)
    image_data, error = _generate_image_google_dedicated(prompt)
    if image_data:
        return image_data, "Google-Gen", ""
    errors.append(f"Google-Gen: {error}")

    # éƒ½å¤±è´¥äº†
    return None, "", f"æ‰€æœ‰APIéƒ½å¤±è´¥: {' | '.join(errors)}"


# ==================== SQLite å­˜å‚¨æ¨¡å— ====================

def _get_db_path() -> Path:
    """è·å–æ•°æ®åº“è·¯å¾„"""
    db_dir = Path.home() / ".gchat"
    db_dir.mkdir(exist_ok=True)
    return db_dir / "gchat.db"


def _init_db():
    """åˆå§‹åŒ–SQLiteæ•°æ®åº“å’Œè¡¨ç»“æ„"""
    db_path = _get_db_path()
    conn = sqlite3.connect(db_path)
    cursor = conn.cursor()

    # å›¾ç‰‡ç”Ÿæˆå†å²è¡¨
    cursor.execute('''
        CREATE TABLE IF NOT EXISTS image_generations (
            id INTEGER PRIMARY KEY AUTOINCREMENT,
            timestamp TEXT NOT NULL,
            prompt TEXT NOT NULL,
            url TEXT,
            model TEXT,
            source TEXT,
            ref_image TEXT,
            gen_time REAL,
            upload_time REAL
        )
    ''')

    # å›¾ç‰‡æè¿°å†å²è¡¨
    cursor.execute('''
        CREATE TABLE IF NOT EXISTS image_descriptions (
            id INTEGER PRIMARY KEY AUTOINCREMENT,
            timestamp TEXT NOT NULL,
            image_path TEXT NOT NULL,
            json_result TEXT,
            model TEXT,
            source TEXT
        )
    ''')

    # åˆ›å»ºç´¢å¼•åŠ é€ŸæŸ¥è¯¢
    cursor.execute('CREATE INDEX IF NOT EXISTS idx_gen_timestamp ON image_generations(timestamp)')
    cursor.execute('CREATE INDEX IF NOT EXISTS idx_desc_timestamp ON image_descriptions(timestamp)')

    conn.commit()
    conn.close()


def _save_image_history(prompt: str, url: str, model: str, source: str, ref_image: str = None,
                        gen_time: float = None, upload_time: float = None):
    """ä¿å­˜å›¾ç‰‡ç”Ÿæˆå†å²åˆ°SQLite"""
    from datetime import datetime

    _init_db()
    conn = sqlite3.connect(_get_db_path())
    cursor = conn.cursor()

    cursor.execute('''
        INSERT INTO image_generations (timestamp, prompt, url, model, source, ref_image, gen_time, upload_time)
        VALUES (?, ?, ?, ?, ?, ?, ?, ?)
    ''', (datetime.now().isoformat(), prompt, url, model, source, ref_image, gen_time, upload_time))

    conn.commit()
    conn.close()


def _save_image_description(image_path: str, json_result: str, model: str, source: str):
    """ä¿å­˜å›¾ç‰‡æè¿°åˆ°SQLite"""
    from datetime import datetime

    _init_db()
    conn = sqlite3.connect(_get_db_path())
    cursor = conn.cursor()

    cursor.execute('''
        INSERT INTO image_descriptions (timestamp, image_path, json_result, model, source)
        VALUES (?, ?, ?, ?, ?)
    ''', (datetime.now().isoformat(), image_path, json_result, model, source))

    conn.commit()
    conn.close()


def query_image_history(limit: int = 20, search: str = None, desc_only: bool = False) -> str:
    """æŸ¥è¯¢å›¾ç‰‡å†å²è®°å½•

    Args:
        limit: è¿”å›è®°å½•æ•°é‡
        search: æœç´¢å…³é”®è¯ (åŒ¹é…promptæˆ–image_path)
        desc_only: ä»…æ˜¾ç¤ºæè¿°å†å²

    Returns:
        æ ¼å¼åŒ–çš„å†å²è®°å½•å­—ç¬¦ä¸²
    """
    _init_db()
    conn = sqlite3.connect(_get_db_path())
    conn.row_factory = sqlite3.Row
    cursor = conn.cursor()

    results = []

    if not desc_only:
        # æŸ¥è¯¢å›¾ç‰‡ç”Ÿæˆå†å²
        if search:
            cursor.execute('''
                SELECT * FROM image_generations
                WHERE prompt LIKE ?
                ORDER BY timestamp DESC LIMIT ?
            ''', (f'%{search}%', limit))
        else:
            cursor.execute('''
                SELECT * FROM image_generations
                ORDER BY timestamp DESC LIMIT ?
            ''', (limit,))

        gen_rows = cursor.fetchall()
        for row in gen_rows:
            time_str = row['timestamp'][:19].replace('T', ' ')
            gen_info = f" ({row['gen_time']:.1f}s)" if row['gen_time'] else ""
            results.append(f"[ç”Ÿæˆ] {time_str} | {row['source']}{gen_info}")
            results.append(f"       {row['prompt'][:80]}{'...' if len(row['prompt']) > 80 else ''}")
            results.append(f"       â†’ {row['url']}")
            # æ˜¾ç¤ºå‚è€ƒå›¾ç‰‡
            if row['ref_image']:
                ref_urls = row['ref_image'].split(',')
                for i, ref in enumerate(ref_urls, 1):
                    results.append(f"       å‚è€ƒ{i}: {ref}")
            results.append("")

    # æŸ¥è¯¢å›¾ç‰‡æè¿°å†å²
    if search:
        cursor.execute('''
            SELECT * FROM image_descriptions
            WHERE image_path LIKE ? OR json_result LIKE ?
            ORDER BY timestamp DESC LIMIT ?
        ''', (f'%{search}%', f'%{search}%', limit))
    else:
        cursor.execute('''
            SELECT * FROM image_descriptions
            ORDER BY timestamp DESC LIMIT ?
        ''', (limit,))

    desc_rows = cursor.fetchall()
    for row in desc_rows:
        time_str = row['timestamp'][:19].replace('T', ' ')
        results.append(f"[æè¿°] {time_str} | {row['source']} | {row['model']}")
        results.append(f"       {row['image_path']}")
        # æ˜¾ç¤ºJSONæ‘˜è¦
        try:
            json_obj = json.loads(row['json_result'])
            if 'subjects' in json_obj:
                subjects = json_obj.get('subjects', [])
                if subjects and isinstance(subjects, list):
                    first_subject = subjects[0] if subjects else {}
                    appearance = first_subject.get('appearance', '')[:40] if isinstance(first_subject, dict) else ''
                    results.append(f"       ä¸»ä½“: {appearance}...")
        except:
            results.append(f"       {row['json_result'][:60]}...")
        results.append("")

    conn.close()

    if not results:
        return "æš‚æ— å†å²è®°å½•"

    return "\n".join(results)


def _get_styles_dir() -> str:
    """è·å–é£æ ¼ç›®å½•è·¯å¾„"""
    import os
    styles_dir = os.path.expanduser("~/.gchat/styles")
    os.makedirs(styles_dir, exist_ok=True)
    return styles_dir


def list_styles() -> list:
    """åˆ—å‡ºæ‰€æœ‰å¯ç”¨çš„é£æ ¼"""
    import os
    import json

    styles_dir = _get_styles_dir()
    styles = []

    if not os.path.exists(styles_dir):
        return styles

    for filename in os.listdir(styles_dir):
        if filename.endswith(".json") and filename != "README.md":
            filepath = os.path.join(styles_dir, filename)
            try:
                with open(filepath, "r", encoding="utf-8") as f:
                    style = json.load(f)
                    styles.append(style)
            except:
                pass

    return styles


def get_style(style_id: str):
    """æ ¹æ®IDè·å–é£æ ¼å®šä¹‰"""
    for style in list_styles():
        if style.get("style_id") == style_id:
            return style
    return None


def query_style(style_id: str = "") -> str:
    """æŸ¥è¯¢é£æ ¼ä¿¡æ¯

    Args:
        style_id: é£æ ¼IDï¼Œç©ºå­—ç¬¦ä¸²è¡¨ç¤ºåˆ—å‡ºæ‰€æœ‰é£æ ¼

    Returns:
        æ ¼å¼åŒ–çš„é£æ ¼ä¿¡æ¯å­—ç¬¦ä¸²
    """
    styles = list_styles()

    if not styles:
        return "æš‚æ— é£æ ¼å®šä¹‰ï¼Œè¯·åœ¨ ~/.gchat/styles/ ç›®å½•ä¸‹åˆ›å»ºé£æ ¼JSONæ–‡ä»¶"

    # å¦‚æœæŒ‡å®šäº†é£æ ¼IDï¼Œæ˜¾ç¤ºè¯¦æƒ…
    if style_id:
        style = get_style(style_id)
        if not style:
            # å°è¯•æ¨¡ç³ŠåŒ¹é…
            for s in styles:
                if style_id.lower() in s.get("style_id", "").lower() or style_id in s.get("name", ""):
                    style = s
                    break

        if not style:
            available = ", ".join([s.get("style_id", "") for s in styles])
            return f"æœªæ‰¾åˆ°é£æ ¼ '{style_id}'\nå¯ç”¨é£æ ¼: {available}"

        # æ˜¾ç¤ºé£æ ¼è¯¦æƒ…
        lines = []
        lines.append(f"=== {style.get('name', '')} ===")
        lines.append(f"ID: {style.get('style_id', '')}")
        lines.append(f"æè¿°: {style.get('description', '')}")
        lines.append(f"æ ‡ç­¾: {', '.join(style.get('tags', []))}")

        if "color_palette" in style:
            palette = style["color_palette"]
            lines.append(f"è‰²å½©: ä¸»è‰² {palette.get('primary', [])} / ç‚¹ç¼€ {palette.get('accent', [])}")

        if "prompt_template" in style:
            lines.append(f"æç¤ºè¯æ¨¡æ¿: {style['prompt_template']}")

        if "example_poses" in style:
            lines.append(f"å§¿åŠ¿ç¤ºä¾‹: {', '.join(style.get('example_poses', []))}")

        if "example_settings" in style:
            lines.append(f"åœºæ™¯ç¤ºä¾‹: {', '.join(style.get('example_settings', []))}")

        if "reference_images" in style and style["reference_images"]:
            lines.append("å‚è€ƒå›¾:")
            for ref in style["reference_images"][:3]:  # åªæ˜¾ç¤ºå‰3å¼ 
                lines.append(f"  - {ref}")

        return "\n".join(lines)

    # åˆ—å‡ºæ‰€æœ‰é£æ ¼
    lines = ["=== å¯ç”¨é£æ ¼ ==="]
    for style in styles:
        style_id = style.get("style_id", "")
        name = style.get("name", "")
        tags = ", ".join(style.get("tags", [])[:3])  # åªæ˜¾ç¤ºå‰3ä¸ªæ ‡ç­¾
        desc = style.get("description", "")[:40] + "..." if len(style.get("description", "")) > 40 else style.get("description", "")
        lines.append(f"\n[{style_id}] {name}")
        lines.append(f"    æ ‡ç­¾: {tags}")
        lines.append(f"    {desc}")

    lines.append(f"\nä½¿ç”¨: turing -S <é£æ ¼ID> æŸ¥çœ‹è¯¦æƒ…")
    return "\n".join(lines)


def generate_and_upload_image(prompt: str, model: str = DEFAULT_IMAGE_MODEL, verbose: bool = True, ref_images: list = None) -> str:
    """ç”Ÿæˆå›¾ç‰‡å¹¶ä¸Šä¼ åˆ° R2ï¼Œè¿”å›å…¬å¼€URLæˆ–é”™è¯¯ä¿¡æ¯

    Args:
        prompt: å›¾ç‰‡ç”Ÿæˆæç¤ºè¯
        model: å›¾ç‰‡ç”Ÿæˆæ¨¡å‹
        verbose: æ˜¯å¦æ˜¾ç¤ºè¯¦ç»†ä¿¡æ¯
        ref_images: å‚è€ƒå›¾ç‰‡è·¯å¾„åˆ—è¡¨ (å«å›¾ï¼Œç”¨äºå›¾ç”Ÿå›¾ï¼Œæœ€å¤š3å¼ )
    """
    from datetime import datetime
    import hashlib

    start_time = time.time()

    # å¦‚æœæœ‰å‚è€ƒå›¾ç‰‡ï¼Œè¯»å–å¹¶ç¼–ç ï¼ˆæ”¯æŒå¤šå¼ ï¼‰
    ref_image_data_list = None
    if ref_images:
        if len(ref_images) > 3:
            return f"[é”™è¯¯] å‚è€ƒå›¾ç‰‡æœ€å¤šæ”¯æŒ3å¼ ï¼Œå½“å‰ä¼ å…¥{len(ref_images)}å¼ "
        ref_image_data_list = []
        for ref_image in ref_images:
            # æ”¯æŒæœ¬åœ°è·¯å¾„å’Œç½‘ç»œURL
            ref_path = resolve_image_path(ref_image)
            if ref_path:
                with open(ref_path, "rb") as f:
                    ref_image_data_list.append(base64.b64encode(f.read()).decode())
            else:
                return f"[é”™è¯¯] å‚è€ƒå›¾ç‰‡ä¸å­˜åœ¨æˆ–ä¸‹è½½å¤±è´¥: {ref_image}"

    # ç”Ÿæˆå›¾ç‰‡
    image_data, source, error = generate_image(prompt, model, ref_image_data_list)
    if error:
        return error
    if not image_data:
        return "[é”™è¯¯] å›¾ç‰‡ç”Ÿæˆå¤±è´¥ï¼Œæ— æ•°æ®è¿”å›"

    gen_time = time.time() - start_time

    # ç”Ÿæˆè¯­ä¹‰åŒ–æ–‡ä»¶å: gchat_YYYYMMDD_HHMMSS_<hash>.png
    timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
    prompt_hash = hashlib.md5(prompt.encode()).hexdigest()[:6]
    filename = f"gchat_{timestamp}_{prompt_hash}.png"

    # ä¸Šä¼ åˆ° R2
    upload_start = time.time()
    url = upload_to_r2(image_data, filename)
    upload_time = time.time() - upload_start
    total_time = time.time() - start_time

    # ä¿å­˜å†å²è®°å½•ï¼ˆä¿å­˜æ‰€æœ‰å‚è€ƒå›¾ï¼Œç”¨é€—å·åˆ†éš”ï¼‰
    ref_image_for_history = ','.join(ref_images) if ref_images else None
    if url.startswith("http"):
        _save_image_history(prompt, url, model, source, ref_image_for_history, gen_time, upload_time)

    # è¿”å›ç»“æœï¼ˆåŒ…å«å…ƒä¿¡æ¯ï¼‰
    if url.startswith("http"):
        if verbose:
            ref_info = f" [å«å›¾: {len(ref_images)}å¼ ]" if ref_images else ""
            return f"{url}\n[{source}] {gen_time:.1f}sç”Ÿæˆ + {upload_time:.1f}sä¸Šä¼  = {total_time:.1f}s{ref_info}"
        return url
    return url  # é”™è¯¯ä¿¡æ¯


# JSONæè¿°æç¤ºè¯æ¨¡æ¿
JSON_DESCRIBE_PROMPT = """è¯·ä½¿ç”¨JSONæ ¼å¼è¯¦ç»†æè¿°è¿™å¼ ç…§ç‰‡ï¼ŒåŒ…æ‹¬ï¼š
- å›¾ç‰‡å°ºå¯¸ (width, height)
- ä¸»ä½“å¯¹è±¡ (subjects)
  - ä½ç½® (position)
  - å¤–è§‚ (appearance)
  - æœè£… (clothing)
  - è¡¨æƒ… (expression)
- èƒŒæ™¯ç¯å¢ƒ (background)
- å…‰çº¿æ¡ä»¶ (lighting)
- è‰²å½©é£æ ¼ (color_style)
- æ„å›¾æ–¹å¼ (composition)

è¾“å‡ºä¸¥æ ¼æœ‰æ•ˆçš„JSONæ ¼å¼ã€‚"""


def _describe_image_api(image_b64: str, model: str, api_url: str, api_key: str = None) -> tuple[str, str]:
    """å†…éƒ¨å‡½æ•°ï¼šè°ƒç”¨APIè·å–å›¾ç‰‡æè¿°

    Returns:
        (json_content, error_message) - æˆåŠŸè¿”å›(json, ""), å¤±è´¥è¿”å›("", error)
    """
    import urllib.request
    import urllib.error

    headers = {"Content-Type": "application/json"}
    if api_key:
        headers["Authorization"] = f"Bearer {api_key}"

    content = [
        {"type": "text", "text": JSON_DESCRIBE_PROMPT},
        {"type": "image_url", "image_url": {"url": f"data:image/png;base64,{image_b64}"}}
    ]

    data = json.dumps({
        "model": model,
        "messages": [{"role": "user", "content": content}],
        "max_tokens": 4096
    }).encode('utf-8')

    req = urllib.request.Request(api_url, data=data, headers=headers, method='POST')

    try:
        with urllib.request.urlopen(req, timeout=90) as response:
            result = json.loads(response.read().decode('utf-8'))

            if "choices" in result and len(result["choices"]) > 0:
                msg_content = result["choices"][0].get("message", {}).get("content", "")
                if isinstance(msg_content, str):
                    import re
                    json_match = re.search(r'```json\s*([\s\S]*?)\s*```', msg_content)
                    if json_match:
                        return json_match.group(1).strip(), ""
                    json_match = re.search(r'\{[\s\S]*\}', msg_content)
                    if json_match:
                        return json_match.group(0), ""
                    return msg_content, ""
                return str(msg_content), ""

            return "", f"å“åº”å¼‚å¸¸: {json.dumps(result, ensure_ascii=False)[:200]}"

    except urllib.error.HTTPError as e:
        error_body = e.read().decode('utf-8') if e.fp else str(e)
        return "", f"HTTP {e.code}: {error_body[:100]}"
    except Exception as e:
        return "", str(e)


def describe_image_json(image_path: str, model: str = "gemini-3-flash-preview") -> str:
    """è·å–å›¾ç‰‡çš„JSONæè¿° (ç”¨äºç²¾å‡†ä¿®å›¾)

    é™çº§é“¾: YUNWU -> Google-API
    æ”¯æŒæœ¬åœ°è·¯å¾„å’Œç½‘ç»œURL

    Args:
        image_path: å›¾ç‰‡è·¯å¾„æˆ–URL
        model: ä½¿ç”¨çš„æ¨¡å‹

    Returns:
        JSONæ ¼å¼çš„å›¾ç‰‡æè¿°ï¼Œæˆ–é”™è¯¯ä¿¡æ¯
    """
    # è¯»å–å›¾ç‰‡å¹¶ç¼–ç ï¼ˆæ”¯æŒæœ¬åœ°è·¯å¾„å’Œç½‘ç»œURLï¼‰
    img_path = resolve_image_path(image_path)
    if not img_path:
        return f"[é”™è¯¯] å›¾ç‰‡ä¸å­˜åœ¨æˆ–ä¸‹è½½å¤±è´¥: {image_path}"

    with open(img_path, "rb") as f:
        image_b64 = base64.b64encode(f.read()).decode()

    errors = []

    # 1. ä¼˜å…ˆä½¿ç”¨ YUNWU (æœ‰ä½™é¢)
    result, error = _describe_image_api(
        image_b64, model,
        YUNWU_IMAGE_CONFIG["url"],
        YUNWU_IMAGE_CONFIG["key"]
    )
    if result:
        # ä¿å­˜åˆ°SQLite
        _save_image_description(str(img_path), result, model, "YUNWU")
        return result
    errors.append(f"YUNWU: {error}")

    # 2. é™çº§åˆ° Google-API
    result, error = _describe_image_api(
        image_b64, model,
        GOOGLE_API_IMAGE_CONFIG["url"]
    )
    if result:
        # ä¿å­˜åˆ°SQLite
        _save_image_description(str(img_path), result, model, "Google-API")
        return result
    errors.append(f"Google-API: {error}")

    return f"[é”™è¯¯] æ‰€æœ‰APIéƒ½å¤±è´¥: {' | '.join(errors)}"


def _generate_image_google_dedicated(prompt: str, ref_image_b64: str = None) -> tuple[bytes, str] | tuple[None, str]:
    """ä½¿ç”¨ google-api ä¸“ç”¨å›¾ç‰‡ç«¯ç‚¹ç”Ÿæˆå›¾ç‰‡

    - æ–‡ç”Ÿå›¾: /v1/generate-images
    - å›¾ç”Ÿå›¾: /v1/images/edit
    """
    import urllib.request
    import urllib.error

    # ä» GOOGLE_API_URL æå– base URL
    base_url = os.environ.get("GOOGLE_API_URL", "").rsplit("/v1/", 1)[0]
    if not base_url:
        return None, "æœªé…ç½® GOOGLE_API_URL"

    if ref_image_b64:
        # å›¾ç”Ÿå›¾ï¼šä½¿ç”¨ /v1/images/edit
        url = f"{base_url}/v1/images/edit"
        payload = {
            "prompt": prompt,
            "image": f"data:image/png;base64,{ref_image_b64}",
            "response_type": "base64"
        }
    else:
        # æ–‡ç”Ÿå›¾ï¼šä½¿ç”¨ /v1/generate-images
        url = f"{base_url}/v1/generate-images"
        payload = {
            "prompt": prompt,
            "response_type": "base64"
        }

    headers = {"Content-Type": "application/json"}
    data = json.dumps(payload).encode('utf-8')
    req = urllib.request.Request(url, data=data, headers=headers, method='POST')

    try:
        with urllib.request.urlopen(req, timeout=120) as response:
            result = json.loads(response.read().decode('utf-8'))

            if "images" in result and len(result["images"]) > 0:
                img_data = result["images"][0]
                # ç§»é™¤ data:image å‰ç¼€
                if img_data.startswith("data:image"):
                    img_data = img_data.split(",", 1)[1]
                return base64.b64decode(img_data), ""

            return None, f"å“åº”å¼‚å¸¸: {json.dumps(result, ensure_ascii=False)[:200]}"

    except urllib.error.HTTPError as e:
        error_body = e.read().decode('utf-8') if e.fp else str(e)
        return None, f"HTTP {e.code}: {error_body[:200]}"
    except Exception as e:
        return None, str(e)


def edit_image_with_json(image_path: str, json_desc: str, model: str = DEFAULT_IMAGE_MODEL, verbose: bool = True) -> str:
    """æ ¹æ®JSONæè¿°ç”Ÿæˆæ–°å›¾ç‰‡ (JSONç²¾å‡†ä¿®å›¾)

    æ”¯æŒæœ¬åœ°è·¯å¾„å’Œç½‘ç»œURLä½œä¸ºå‚è€ƒå›¾

    Args:
        image_path: åŸå›¾è·¯å¾„æˆ–URL (å¯é€‰ï¼Œç”¨äºå‚è€ƒ)
        json_desc: ä¿®æ”¹åçš„JSONæè¿°
        model: å›¾ç‰‡ç”Ÿæˆæ¨¡å‹
        verbose: æ˜¯å¦æ˜¾ç¤ºè¯¦ç»†ä¿¡æ¯

    Returns:
        ç”Ÿæˆå›¾ç‰‡çš„URLæˆ–é”™è¯¯ä¿¡æ¯
    """
    # æ„å»ºç”Ÿæˆæç¤ºè¯
    prompt = f"è¯·æ ¹æ®ä»¥ä¸‹JSONæè¿°ç”Ÿæˆä¸€å¼ æ–°å›¾ç‰‡ï¼š\n\n{json_desc}"

    # å¦‚æœæä¾›äº†åŸå›¾ï¼Œä½œä¸ºå‚è€ƒï¼ˆæ”¯æŒURLå’Œæœ¬åœ°è·¯å¾„ï¼‰
    ref_images = [image_path] if image_path else None

    return generate_and_upload_image(prompt, model, verbose, ref_images)


def single_prompt(prompt, model, output_json=False, use_stream=False):
    """å•æ¬¡æé—®æ¨¡å¼"""
    backend_config = BACKEND_CONFIG
    model = resolve_model(model)

    # æå–å›¾ç‰‡è·¯å¾„ï¼ˆæ”¯æŒå¸¦ç©ºæ ¼çš„è·¯å¾„ï¼‰
    cleaned_text, image_paths = extract_local_image_paths(prompt)

    # æ„å»ºæ¶ˆæ¯
    if image_paths:
        # å¤šæ¨¡æ€æ¶ˆæ¯ï¼ˆåŒ…å«å›¾ç‰‡ï¼‰
        user_message = {
            "role": "user",
            "content": [{"type": "text", "text": cleaned_text or "è¯·åˆ†æå›¾ç‰‡"}] + [
                {"type": "image_file", "path": str(p)} for p in image_paths
            ],
        }
        messages = [user_message]
    else:
        # çº¯æ–‡æœ¬æ¶ˆæ¯
        messages = [{"role": "user", "content": prompt}]

    if use_stream and not output_json:
        response = chat_request_with_fallback_stream(messages, model, backend_config, quiet=True, show_spinner=False)
    else:
        response = chat_request_with_fallback(messages, model, backend_config, quiet=True, show_spinner=False)

    if output_json:
        result = {
            "model": model,
            "backend": os.path.basename(sys.argv[0]),  # ä½¿ç”¨å‘½ä»¤åç§°ä½œä¸º backend
            "prompt": prompt,
            "response": response,
            "success": not response.startswith("[")
        }
        print(json.dumps(result, ensure_ascii=False, indent=2))
    elif not use_stream:
        print(response)

def list_models():
    """åˆ—å‡ºå¯ç”¨æ¨¡å‹"""
    command_name = os.path.basename(sys.argv[0]).upper()
    print("å¯ç”¨æ¨¡å‹:")
    print("  flash   -> gemini-3-flash-preview (æœ€æ–° 3.0 Flash) â­ æ¨è")
    print("  flash3  -> gemini-3-flash-preview (åŒä¸Š)")
    print("  flash2  -> gemini-2.5-flash (æ—§ç‰ˆ Flash)")
    print("  pro     -> gemini-2.5-pro (Pro)")
    print("  pro3    -> gemini-3.0-pro (3.0 Pro)")
    print()
    print(f"å½“å‰é…ç½® ({command_name}):")
    print(f"  BASE_URL: {BACKEND_CONFIG['url'] or 'æœªè®¾ç½®'}")
    print(f"  KEY: {'å·²è®¾ç½®' if BACKEND_CONFIG.get('key') else 'æœªè®¾ç½®'}")
    print()
    print(f"é…ç½®æ–¹å¼:")
    print(f"  export {command_name}_BASE_URL='https://...'")
    print(f"  export {command_name}_KEY='sk-...'")

def main():
    parser = argparse.ArgumentParser(
        description="Gemini Chat CLI - å¤šè½®ä¼šè¯å‘½ä»¤è¡Œå·¥å…· (Claude Code çš„è½»é‡å¤šæ¨¡å‹ç½‘å…³)",
        formatter_class=argparse.RawDescriptionHelpFormatter,
        epilog="""
ç¤ºä¾‹:
  gchat                    å¼€å¯æ–°å¯¹è¯ (æµå¼è¾“å‡º)
  gchat -c                 ç»§ç»­ä¸Šæ¬¡å¯¹è¯
  gchat -m pro             ä½¿ç”¨ pro æ¨¡å‹
  gchat -p "è§£é‡Šé‡å­è®¡ç®—"   å•æ¬¡æé—®
  gchat -p "é—®é¢˜" --json   JSON æ ¼å¼è¾“å‡º (è„šæœ¬é›†æˆ)

é…ç½®:
  é€šè¿‡ç¯å¢ƒå˜é‡é…ç½®ä¾›åº”å•†:
  export GCHAT_BASE_URL="https://api.provider.com/v1/chat/completions"
  export GCHAT_KEY="sk-your-api-key"

å›¾ç‰‡åŠŸèƒ½:
  gchat -d a cute cat              ç”Ÿæˆå›¾ç‰‡ (å…å¼•å·)
  gchat -d "ä¿®æ”¹æç¤º" -r img1.png img2.png img3.png   å›¾ç”Ÿå›¾ (å«å›¾ï¼Œæœ€å¤š3å¼ )
  gchat -D photo.jpg               è·å–å›¾ç‰‡JSONæè¿° (ç²¾å‡†ä¿®å›¾)
  gchat -E desc.json               æ ¹æ®JSONç”Ÿæˆæ–°å›¾
  gchat -E desc.json -r orig.jpg   JSONä¿®å›¾ (å‚è€ƒåŸå›¾)
  gchat -H                         æŸ¥çœ‹å›¾ç‰‡å†å²
  gchat -H cat                     æœç´¢å†å² (å…³é”®è¯: cat)

äº¤äº’å‘½ä»¤:
  /read <file>   è¯»å–æ–‡ä»¶è®© AI åˆ†æ
  /write <file>  ä¿å­˜ AI å›å¤åˆ°æ–‡ä»¶
  /sessions      åˆ—å‡ºæ‰€æœ‰ä¼šè¯
  /stream        åˆ‡æ¢æµå¼è¾“å‡º
  /help          æŸ¥çœ‹æ›´å¤šå‘½ä»¤
        """
    )

    parser.add_argument('-m', '--model', default='flash3',
                        help='æ¨¡å‹åç§° (flash3/pro3/pro/flashï¼Œé»˜è®¤: flash3)')
    parser.add_argument('-p', '--prompt',
                        help='å•æ¬¡æé—®ï¼ˆä¸è¿›å…¥äº¤äº’æ¨¡å¼ï¼‰')
    parser.add_argument('-c', '--continue', dest='continue_session', action='store_true',
                        help='ç»§ç»­ä¸Šæ¬¡ä¼šè¯ï¼ˆè‡ªåŠ¨åŠ è½½æœ€è¿‘çš„å†å²è®°å½•ï¼‰')
    parser.add_argument('--json', dest='output_json', action='store_true',
                        help='è¾“å‡º JSON æ ¼å¼ï¼ˆç”¨äºè„šæœ¬é›†æˆï¼‰')
    parser.add_argument('--no-stream', dest='no_stream', action='store_true',
                        help='ç¦ç”¨æµå¼è¾“å‡º')
    parser.add_argument('-q', '--quiet', action='store_true',
                        help='å®‰é™æ¨¡å¼ï¼ˆä¸æ˜¾ç¤ºäº¤äº’å¼UIï¼Œä»…è¾“å‡ºç»“æœï¼‰')
    parser.add_argument('--list-models', action='store_true',
                        help='åˆ—å‡ºå¯ç”¨æ¨¡å‹å’Œåç«¯')
    parser.add_argument('--draw', '-d', nargs='*', metavar='WORD',
                        help='ç”Ÿæˆå›¾ç‰‡ï¼Œæ”¯æŒå…å¼•å· (å¦‚: gchat -d a cute cat)')
    parser.add_argument('--image-model', type=str, default=DEFAULT_IMAGE_MODEL,
                        help='å›¾ç‰‡ç”Ÿæˆæ¨¡å‹ (image, image-flash)')
    parser.add_argument('--ref', '-r', nargs='*', metavar='IMAGE_PATH',
                        help='å‚è€ƒå›¾ç‰‡è·¯å¾„ï¼Œæœ€å¤š3å¼  (å«å›¾ï¼Œç”¨äºå›¾ç”Ÿå›¾)')
    parser.add_argument('--describe', '-D', type=str, metavar='IMAGE_PATH',
                        help='è·å–å›¾ç‰‡çš„JSONæè¿° (ç”¨äºç²¾å‡†ä¿®å›¾)')
    parser.add_argument('--edit-json', '-E', type=str, metavar='JSON_FILE',
                        help='æ ¹æ®JSONæè¿°ç”Ÿæˆæ–°å›¾ç‰‡ (JSONç²¾å‡†ä¿®å›¾)')
    parser.add_argument('--style', '-S', nargs='?', const='', metavar='STYLE_ID',
                        help='ä½¿ç”¨é£æ ¼ (æ— å‚æ•°=åˆ—å‡ºæ‰€æœ‰é£æ ¼, æŒ‡å®šID=æŸ¥çœ‹è¯¦æƒ…)')
    parser.add_argument('--image-history', '-H', nargs='?', const='', metavar='SEARCH',
                        help='æŸ¥çœ‹å›¾ç‰‡å†å² (å¯é€‰æœç´¢å…³é”®è¯)')
    parser.add_argument('--history-limit', type=int, default=20,
                        help='å†å²è®°å½•è¿”å›æ•°é‡ (é»˜è®¤20)')

    args = parser.parse_args()

    if args.list_models:
        list_models()
        return

    # é£æ ¼æŸ¥è¯¢æ¨¡å¼
    if args.style is not None:
        result = query_style(args.style)
        print(result)
        return

    # å›¾ç‰‡å†å²æŸ¥è¯¢æ¨¡å¼
    if args.image_history is not None:
        search = args.image_history if args.image_history else None
        result = query_image_history(limit=args.history_limit, search=search)
        print(result)
        return

    # JSONæè¿°æ¨¡å¼
    if args.describe:
        print(f"æ­£åœ¨è·å–å›¾ç‰‡JSONæè¿°: {args.describe}")
        result = describe_image_json(args.describe)
        print(result)
        return

    # JSONç²¾å‡†ä¿®å›¾æ¨¡å¼
    if args.edit_json:
        json_path = Path(args.edit_json).expanduser()
        if not json_path.exists():
            print(f"[é”™è¯¯] JSONæ–‡ä»¶ä¸å­˜åœ¨: {args.edit_json}")
            return
        with open(json_path, 'r', encoding='utf-8') as f:
            json_desc = f.read()
        print(f"æ­£åœ¨æ ¹æ®JSONç”Ÿæˆå›¾ç‰‡...")
        image_model = IMAGE_MODELS.get(args.image_model, args.image_model)
        # JSONä¿®å›¾æ¨¡å¼åªä½¿ç”¨ç¬¬ä¸€å¼ å‚è€ƒå›¾
        ref_image = args.ref[0] if args.ref else None
        result = edit_image_with_json(ref_image, json_desc, image_model)
        print(result)
        return

    if args.draw is not None:
        # å›¾ç‰‡ç”Ÿæˆæ¨¡å¼ (æ”¯æŒå…å¼•å·: gchat -d a cute cat)
        prompt = ' '.join(args.draw) if args.draw else ""
        if not prompt:
            print("[é”™è¯¯] è¯·æä¾›å›¾ç‰‡ç”Ÿæˆæç¤ºè¯")
            return
        image_model = IMAGE_MODELS.get(args.image_model, args.image_model)
        result = generate_and_upload_image(prompt, image_model, ref_images=args.ref)
        print(result)
        return

    if args.prompt:
        single_prompt(args.prompt, args.model,
                     output_json=args.output_json,
                     use_stream=False)
    else:
        interactive_mode(args.model,
                        continue_session=args.continue_session)

if __name__ == "__main__":
    main()
